<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"coreLibrary.js.html":{"id":"coreLibrary.js.html","title":"Source: coreLibrary.js","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Source: coreLibrary.js import offeringModule from './Module/offeringModule'; import statisticsModule from './Module/statisticsModule'; import translationModule from './Module/translationModule'; import utilModule from './Module/utilModule'; import widgetModule from './Module/widgetModule'; /** * Main module that holds the other modules as well as widget * related configurations * @module coreLibrary */ function checkStatus(response) { if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) { return response; } else { var error = new Error(response.statusText); error.response = response; throw error; } } function checkBrowser() { var ua = window.navigator.userAgent; var getFirstMatch = function (regex) { var match = ua.match(regex); return (match &amp;&amp; match.length &gt; 1 &amp;&amp; match[1]) || ''; }; var versionIdentifier = getFirstMatch(/version\\/(\\d+(\\.\\d+)?)/i); if (/android/i.test(ua)) { return { browser: 'android', browserVersion: versionIdentifier }; } else if (/(ipod|iphone|ipad)/i.test(ua)) { return { browser: 'ios', browserVersion: getFirstMatch(/(?:mxios)[\\s/](\\d+(?:\\.\\d+)+)/i) }; } else if (/msie|trident/i.test(ua)) { return { browser: 'internet-explorer', browserVersion: getFirstMatch(/(?:msie |rv:)(\\d+(\\.\\d+)?)/i) }; } else if (/chrome|crios|crmo/i.test(ua)) { return { browser: 'chrome', browserVersion: getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.\\d+)?)/i) }; } else if (/safari|applewebkit/i.test(ua)) { return { browser: 'safari', browserVersion: versionIdentifier }; } else if (/chrome.+? edge/i.test(ua)) { return { browser: 'microsoft-edge', browserVersion: getFirstMatch(/edge\\/(\\d+(\\.\\d+)?)/i) }; } else if (/firefox|iceweasel|fxios/i.test(ua)) { return { browser: 'firefox', browserVersion: getFirstMatch(/(?:firefox|iceweasel|fxios)[ /](\\d+(\\.\\d+)?)/i) }; } } /* * Downloads a resource from given URL. * @param {string} url URL of resource * @returns {Promise.&lt;{status: number, statusText: string, body: string}&gt;} */ function download(url) { return new Promise((resolve, reject) =&gt; { // fetch API is not supported in IE11 so we use // old-school XMLHttpRequest const xhr = new XMLHttpRequest(); xhr.open('GET', url, true); xhr.onload = function() { const response = { status: xhr.status, statusText: xhr.statusText, body: 'response' in xhr ? xhr.response : xhr.responseText, }; resolve(response); }; xhr.onerror = () =&gt; reject(new TypeError('Network request failed')); xhr.ontimeout = () =&gt; reject(new TypeError('Network request failed')); xhr.send(); }); } export default { /** * Name of the browser that is running the widget * @type {String} */ browser: checkBrowser().browser, /** * Browser version * @type {String} */ browserVersion: checkBrowser().browserVersion, /** * Kambi Widget API version to use * @type {String} * @private */ expectedApiVersion: '1.0.0.15', /** * Config object. This data comes from the sportsbook and should not be manually changed. When in running the widget stand alone this values are retrieved from ./src/mockSetupData.json * @name config * @type {Object} * @property {String} apiBaseUrl url of the offering api to use * @property {Boolean} auth * @property {Number} channelId * @property {String} currency what currency to use * @property {String} customer the customer to use with the offering API * @property {String} device what kind of device does the user have. Possible values: 'desktop', 'mobile' * @property {String} locale locale of the user, example: 'en_GB', 'sv_SE' * @property {String} market market to use with the offering API. * @property {String} oddsFormat the odds format to show. Possible values: 'decimal', 'fractional', 'american'. To listen to changes to this value use widgetModule.events.subscribe('ODDS:FORMAT', eventHandlerFn); * @property {String} offering the offering to use with the offering API * @property {String} routeRoot * @property {Boolean} streamingAllowedForPlayer * @property {Number} client_id * @property {String} version */ _config: { apiBaseUrl: '', auth: false, channelId: 1, currency: 'EUR', customer: '', device: 'desktop', locale: 'en_GB', market: 'GB', oddsFormat: 'decimal', offering: '', routeRoot: '', streamingAllowedForPlayer: true, client_id: 2, version: 'v2' }, /** * An array with the default classes that should be added to HTML tag */ kambiDefaultClasses: [ 'KambiWidget-card-text-color', 'KambiWidget-card-background-color', 'KambiWidget-font', ], get config () { return this._config; // eslint-disable-line no-underscore-dangle }, set config (config) { /* eslint-disable no-underscore-dangle */ for (var i in config) { if (config.hasOwnProperty(i) &amp;&amp; this._config.hasOwnProperty(i)) { this._config[i] = config[i]; } } // Make sure that the routeRoot is not null or undefined if (this._config.routeRoot == null) { this._config.routeRoot = ''; } else if (this._config.routeRoot.length &gt; 0 &amp;&amp; this._config.routeRoot.slice(-1) !== '/') { // If the routeRoot is not empty we need to make sure it has a trailing slash this._config.routeRoot += '/'; } /* eslint-enable no-underscore-dangle */ }, /** * Sets odds format. Calling this method changes config.oddsFormat * @memberOf module:coreLibrary * @param {String} oddsFormat * @private */ setOddsFormat (oddsFormat) { this._config.oddsFormat = oddsFormat; // eslint-disable-line no-underscore-dangle }, /** * default args object * @private */ _defaultArgs: {}, get defaultArgs () { return this._defaultArgs; // eslint-disable-line no-underscore-dangle }, set defaultArgs (defaultArgs) { this._defaultArgs = defaultArgs; // eslint-disable-line no-underscore-dangle }, /** * args object for the widget, merges the default args provided by coreLibrary.init() with the ones that come from the sportsbook. There are some pre-defined arguments that all widgets accept, but most of them are widget-defined. * @property {String} customCssUrl URL to a CSS file to add to the page, expressions like &quot;{customer}&quot; are replaced with their values in coreLibrary.config. This is useful to load different stylesheets based on operator name. Example: Say coreLibrary.config.customer is 'kambi', then if this argument was set: { customCssUrl: &quot;https://someurl.com/customcss/{customer}/style.css&quot; } It would load this CSS file and add it to the page: https://someurl.com/customcss/kambi/style.css * @property {String} customCssUrlFallback fallback if the fetching of customCssUrl fails * @property {Array&lt;Object&gt;} conditionalArgs Optional, specify arguments to be applied based on some condition based in the values inside coreLibrary.config or coreLibrary.pageInfo example: conditionalArgs: [ // if coreLibrary.config.currency is 'EUR' apply { euro: true, dollars: false } to the arguments { config: { currency: 'EUR' }, args: { euro: true, dollars: false } }, // if market is 'IT' AND offering is 'IT' apply { italian: true } to the arguments { config: { market: 'IT', offering: 'IT' }, args: { italian: true } }, ] * @name args */ _args: null, get args () { return this._args; // eslint-disable-line no-underscore-dangle }, set args (args) { /* eslint-disable no-underscore-dangle */ if (this._args != null) { throw Error('Do not override coreLibrary.args'); } args = Object.assign({}, this.defaultArgs, args); // Handling conditionalArgs if (args.conditionalArgs != null) { args.conditionalArgs.forEach((carg) =&gt; { var apply = true; if (carg.clientConfig != null) { Object.keys(carg.clientConfig).forEach((key) =&gt; { if (this.config[key] !== carg.clientConfig[key]) { apply = false; } }); } if (carg.pageInfo != null) { Object.keys(carg.pageInfo).forEach((key) =&gt; { if (this.pageInfo[key] !== carg.pageInfo[key]) { apply = false; } }); } if (apply) { console.log('Applying conditional arguments:'); console.log(carg.args); args = Object.assign(args, carg.args); } }); } this._args = args /* eslint-enable no-underscore-dangle */ }, /** * Information about the page that the widget is being loaded from * @name pageInfo * @type {Object} * @property {Array(String)} leaguePaths array with league paths. Example:['football/england/premier_league'] * @property {String} pageParam parameter for this page. For a page of type 'filter' an example would be 'football/england/premier_league' * @property {String} pageTrackingPath the path in the url for this page. For example: '/filter/football/england/premier_league' * @property {String} pageType type of the page, examples: 'home', 'filter' */ _pageInfo: { leaguePaths: [], pageParam: '', pageTrackingPath: '', pageType: '' }, get pageInfo () { return this._pageInfo; // eslint-disable-line no-underscore-dangle }, set pageInfo (pageInfo) { /* eslint-disable no-underscore-dangle */ // Check if the last character in the pageParam property is a slash, if not add it so we can use this property in filter requests if (pageInfo.pageType === 'filter' &amp;&amp; pageInfo.pageParam.substr(-1) !== '/') { pageInfo.pageParam += '/'; } this._pageInfo = pageInfo; /* eslint-enable no-underscore-dangle */ }, /** * Versions of the API provided by the sportsbook * @name apiVersions * @type {Object} * @property {String} client * @property {String} libs * @property {String} wapi */ _apiVersions: { client: '', libs: '', wapi: '' }, get apiVersions () { return this._apiVersions; // eslint-disable-line no-underscore-dangle }, set apiVersions (versions) { /* eslint-disable no-underscore-dangle */ for (var i in versions) { if (versions.hasOwnProperty(i) &amp;&amp; this._apiVersions.hasOwnProperty(i)) { this._apiVersions[i] = versions[i]; } } /* eslint-enable no-underscore-dangle */ }, /** * The name sent to Kambi API for analytics data collection * @private */ widgetTrackingName: null, /** * Promise that is resolved when all the CSS has finished loading * @type Promise */ cssLoadedPromise: null, /** * Initializes the Kambi api * Uses ./src/mockSetupData.json as coreLibrary.configs if not loaded inside the sportsbook (ie opened the widget directly). * @param {Object} defaultArgs arguments to be used if they are not provided by the sportsbook * @returns {Promise} resolved when everything is ready. If an error happens during fetching the error can be catched in a .catch() function */ init (defaultArgs) { this.defaultArgs = defaultArgs; return new Promise((resolve, reject) =&gt; { // injecting widget-api in the page return this.getFile('https://c3-static.kambi.com/sb-mobileclient/widget-api/' + this.expectedApiVersion + '/kambi-widget-api.js') .then((content) =&gt; { const tag = document.createElement('script'); tag.setAttribute('id', 'widget-api'); tag.textContent = content; const head = document.getElementsByTagName('head')[0]; // custom CSS should be the LAST CSS in the page head.insertBefore(tag, head.lastChild); return 'success'; }).catch((err) =&gt; { console.error('Error loading widget api') console.error(err); reject(); }) .then(() =&gt; { // applies the setup data and sets up the CSS and translations var applySetupData = (setupData) =&gt; { this.config = setupData.clientConfig; this.pageInfo = setupData.pageInfo; this.apiVersions = setupData.versions; this.args = setupData.arguments; this.addClasses(this.kambiDefaultClasses); const translationPromise = translationModule.fetchTranslations(setupData.clientConfig.locale); const operatorCssPromise = this.injectOperatorCss( this.expectedApiVersion, this.config.customer, this.config.offering); const customCssPromise = this.injectCustomCss( this.args.customCssUrl, this.args.customCssUrlFallback); // most widgets don't need to wait for the CSS to be loaded // so we keep a promise instead of waiting for it this.cssLoadedPromise = Promise.all([operatorCssPromise, customCssPromise]); translationPromise .then(() =&gt; { resolve(); }) .catch((err) =&gt; { reject(); }); }; if (window.KambiWidget) { // For development purposes we might want to load a widget on it's own so we check if we are in an iframe, if not then load some fake data if (window.self === window.top) { console.warn(window.location.host + window.location.pathname + ' is being loaded as stand-alone'); // Load the mock config data this.getData('mockSetupData.json') .then((mockSetupData) =&gt; { // Output some debug info that could be helpful console.debug('Loaded mock setup data'); console.debug(mockSetupData); // Apply the mock config data to the core applySetupData(mockSetupData); }) .catch((error) =&gt; { console.debug('Failed to fetch mockSetupData'); console.trace(error); reject(); }); } else { window.KambiWidget.apiReady = (api) =&gt; { widgetModule.api = api; // Request the setup info from the widget api widgetModule.requestSetup((setupData) =&gt; { // Request the outcomes from the betslip so we can update our widget, also sets up a subscription for future betslip updates widgetModule.requestBetslipOutcomes(); // Request the odds format that is set in the sportsbook, this also sets up a subscription for future odds format changes widgetModule.requestOddsFormat(); // Apply the config data to the core applySetupData(setupData); }); }; // Setup the response handler for the widget api window.KambiWidget.receiveResponse = (dataObject) =&gt; { widgetModule.handleResponse(dataObject); }; } } else { console.warn('Kambi widget API not loaded'); reject(); } }); }); }, /** * Dynamically creates a style tag and returns it * @param id {String} the id to add to the tag * @param content {String} text content of the tag (the styles) * @returns HTMLElement the tag created * @private */ createStyleTag (id, url) { const tag = document.createElement('link'); tag.setAttribute('id', id); tag.setAttribute('rel', 'stylesheet'); tag.setAttribute('type', 'text/css'); tag.setAttribute('href', url); return tag; }, /** * Injects operator specific CSS based on widget API version, * customer and offering * @param wApiVersion {String|Null} If null will use expectedApiVersion * @param customer {String} * @param offering {String} * @returns {Promise} When resolved the stylesheet has been successfully added to the page * @private */ injectOperatorCss (wApiVersion, customer, offering) { if ( wApiVersion == null || wApiVersion === '') { wApiVersion = this.expectedApiVersion; } const url = '//c3-static.kambi.com/sb-mobileclient/widget-api/' + wApiVersion + '/resources/css/' + customer + '/' + offering + '/widgets.css'; return this.getFile(url) .then((content) =&gt; { const tag = this.createStyleTag('operator-css', url); const head = document.getElementsByTagName('head')[0]; // opereator CSS should be the FIRST CSS in the page head.insertBefore(tag, head.firstChild); }) .catch((err) =&gt; { console.warn('Could not inject Operator CSS'); }); }, /** * Adds classes to to HTML tag * @param classes {Array} An array of strings with the classnames to be addes */ addClasses ( classes ) { const html = document.getElementsByTagName('html')[0]; classes.map((cssClass) =&gt; { html.classList.add(cssClass)}); }, /** * Injects stylesheet based on configuration parameters (coreLibrary.config) * Replaces expressions like &quot;{customer}&quot; in the strings provided * @param customCssUrl {String} * @param customCssUrlFallback {String} Fallback if the first URL fetch fails * @returns {Promise} when resolved the stylesheet has been successfully added to the page * @private */ injectCustomCss (customCssUrl, customCssUrlFallback) { if (customCssUrl == null) { return Promise.resolve(''); } if (customCssUrlFallback == null) { customCssUrlFallback = ''; } customCssUrl = utilModule.replaceConfigParameters(customCssUrl); customCssUrlFallback = utilModule.replaceConfigParameters(customCssUrlFallback); const appendToHead = (url) =&gt; { const tag = this.createStyleTag('custom-css', url); const head = document.getElementsByTagName('head')[0]; // custom CSS should be the LAST CSS in the page head.insertBefore(tag, null); }; return this.getFile(customCssUrl) .then(( response ) =&gt; { appendToHead(customCssUrl); return response; }).catch(( error ) =&gt; { if (customCssUrlFallback !== '') { console.debug('Error fetching custom css, trying fallback'); return this.getFile(customCssUrlFallback) .then(( response ) =&gt; { appendToHead(customCssUrlFallback); return response; }).catch(( error ) =&gt; { console.debug('Error fetching custom css fallback'); return error; }); } else { console.debug('Error fetching custom css, no fallback present'); return error; } }); }, /** * Makes a ajax request and parses its response as JSON * @param {String} url * @returns {Promise} resolved when the data fetching finishes. If an error happens during fetching the error can be catched in a .catch() function */ getData (url) { return download(url) .then(checkStatus) .then((response) =&gt; { return JSON.parse(response.body) }) .catch((error) =&gt; { console.debug('Error fetching data'); console.trace(error); throw error; }); }, /** * Makes an ajax request and returns the response body as text * @param {String} url * @returns {Promise} resolved when the data fetching finishes. If an error happens during fetching the error can be catched in a .catch() function */ getFile (url) { return download(url) .then(checkStatus) .then(response =&gt; response.body) .catch((error) =&gt; { console.debug('Error fetching file'); console.trace(error); throw error; }); }, /** * Sets widget tracking name for analytics purposes. This tracking name is used for calls to add bets to the betslip * @param {String} name The name to use */ setWidgetTrackingName (name) { this.widgetTrackingName = name; } }; × Search results Close "},"Module_offeringModule.js.html":{"id":"Module_offeringModule.js.html","title":"Source: Module/offeringModule.js","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Source: Module/offeringModule.js import coreLibrary from '../coreLibrary'; /** * Module with methods to request data from the offering API * The offering API has information concerning events (matches, competations) and their respective betoffers as well as live data if available * All methods in this module return Promises that are resolved when the data is ready and throws errors (that can be handled with .catch()) on failure * @module offeringModule */ export default { /** * Get group events * @param {number|string} groupId Group id * @returns {Promise} */ getGroupEvents (groupId) { var requesPath = '/event/group/' + groupId + '.json'; return this.doRequest(requesPath); }, /** * Get group information. * @param {Number|String} groupId Group id * @returns {Promise} */ getGroup (groupId) { var requesPath = '/group/' + groupId + '.json'; return this.doRequest(requesPath); }, /** * Get events by filter, only returns the main betoffer for the event. To get all betoffers use getEvent() or getLiveEvent() * @param {String} filter Filter string, eg: football * @param {Object} params Request relevant parameters * @returns {Promise} */ getEventsByFilter (filter, params) { // Todo: Update this method once documentation is available var requestPath = '/listView/' + filter; return this.doRequest(requestPath, params, 'v3'); }, /** * Normalizes v2 api betoffers * @param {Object} betOffer Betoffer object we get from api * @private */ adaptV2BetOffer (betOffer) { if (betOffer.suspended === true) { betOffer.open = false; } }, /** * Normalizes the v2 api response * @param {Object} liveData Livedata object we get from api * @private */ adaptV2LiveData (liveData) { if (liveData != null &amp;&amp; liveData.statistics != null) { var statistics = liveData.statistics; if (statistics.sets != null) { statistics.setBasedStats = statistics.sets; delete statistics.sets; } if (statistics.football != null) { statistics.footballStats = statistics.football; delete statistics.football; } } }, /** * Normalizes the v2 event object * @private */ adaptV2Event (event) { // v3 and v2 event objects are almost the same // only a few attributes we don't use are different }, /** * Get live event data only, eg: match statistics, score, macthClock * @param {Number|String} eventId The event id we need to fetch * @returns {Promise} * @private */ getLiveEventData (eventId) { var requestPath = '/event/' + eventId + '/livedata.json'; return this.doRequest(requestPath, null, null, true) .then((res) =&gt; { this.adaptV2LiveData(res); return res; }); }, /** * Get all live events, only returns the main betoffer for the event. To get all betoffers use getEvent() or getLiveEvent() * @returns {Promise} * @private */ getLiveEvents () { var requestPath = '/event/live/open.json'; return this.doRequest(requestPath, null, null, true) .then((res) =&gt; { if (res.error != null) { return res; } var events = res.liveEvents; res.events = events; res.events.forEach(this.adaptV2Event); delete res.liveEvents; delete res.group; events.forEach((e) =&gt; { e.betOffers = []; if (e.mainBetOffer != null) { this.adaptV2BetOffer(e.mainBetOffer); e.betOffers.push(e.mainBetOffer); delete e.mainBetOffer; } this.adaptV2LiveData(e.liveData); }); return res; }); }, /** * Returns a live event * @param {Number|String} eventId The event id we need to fetch * @returns {Promise} */ getLiveEvent (eventId) { var requestPath = '/betoffer/live/event/' + eventId + '.json'; return this.doRequest(requestPath, null, null, true) .then((res) =&gt; { res.betOffers = res.betoffers; delete res.betoffers; res.betOffers.forEach(this.adaptV2BetOffer); res.event = res.events[0]; this.adaptV2Event(res.event); delete res.events; return res; }); }, /** * Get live events by filter, only returns the main betoffer for the event. To get all betoffers use getEvent() or getLiveEvent() * @param {String} filter Filter string * @returns {Promise} */ getLiveEventsByFilter (filter) { // Todo: implement a filter request when the offering API supports it filter = filter.replace(/\\/$/, ''); var filterTerms = filter.split('/'); filterTerms = filterTerms.slice(0, 3); var requestPath = '/listView/all/all/all/all/in-play/'; return new Promise((resolve, reject) =&gt; { this.doRequest(requestPath, null, 'v3') .then((response) =&gt; { var result = { events: [] }, i = 0, len = response.events.length; for (; i &lt; len; ++i) { var j = 0, termLen = response.events[i].event.path.length, addEvent = true; if (termLen &gt; filterTerms.length) { termLen = filterTerms.length; } for (; j &lt; termLen; ++j) { if (filterTerms[j] !== 'all' &amp;&amp; response.events[i].event.path[j].termKey !== filterTerms[j]) { addEvent = false; } } if (addEvent) { result.events.push(response.events[i]); } } resolve(result); }); }); }, /** * Requests and event from api * @param {String} eventId The event id we need to fetch * @returns {Promise} */ getEvent (eventId) { return this.doRequest('/betoffer/event/' + eventId + '.json') .then((res) =&gt; { res.betOffers = res.betoffers; delete res.betoffers; res.betOffers.forEach(this.adaptV2BetOffer); res.event = res.events[0]; this.adaptV2Event(res.event); delete res.events; return res; }); }, /** * Request the highlight resource which is what is shown under the &quot;Popular&quot; section in the Sportsbook * @returns {Promise} */ getHighlight () { return this.doRequest('/group/highlight.json') .then((highlights) =&gt; { // sorting based on sortOrder if ( Array.isArray(highlights.groups) ) { highlights.groups.sort(( a, b ) =&gt; { if ( parseInt(a.sortOrder, 10) &gt; parseInt(b.sortOrder, 10) ) { return 1; } if ( parseInt(a.sortOrder, 10) &lt; parseInt(b.sortOrder, 10) ) { return -1; } return 0; }); } return highlights; }); }, /** * Makes a request to provided path setting the appropriated URL parameters. Usually this method should not be called directly, unless you want to access an endpoint that is not available in the other methods The final url looks like: coreLibrary.config.apiBaseUrl + version + coreLibrary.config.offering + requestPath Example (same as calling offeringModule.getLiveEvents() but forcing to use Portugal Portuguese locale) doRequest('/event/live/open.json' { lang: 'pt_PT' }); this call would fetch this url: https://api.kambi.com/offering/api/v2/kambi/event/live/open.json?lang=pt_PT&amp;market=kambi&amp;client_id=2&amp;include=&amp;betOffers=COMBINED&amp;categoryGroup=COMBINED&amp;displayDefault=true&amp;nocache=1476973932524 * @param {string} requestPath the path to the request * @param {object} params params to use, can override the parameters this method usually sets * @param {number|string} version which version of the API to use. Some endpoints are 'v2' and some are 'v3' * @param {boolean} noCache if true will add a cache-busting URL parameter. Defaults to true * @returns {Promise} */ doRequest (requestPath, params, version, noCache) { var config = coreLibrary.config; if (config.offering == null) { console.warn('The offering has not been set, is the right widget api version loaded?'); } else { var apiUrl = config.apiBaseUrl.replace('{apiVersion}', (version != null ? version : config.version)); var requestUrl = apiUrl + config.offering + requestPath; var overrideParams = params || {}; var requestParams = { lang: overrideParams.locale || config.locale, market: overrideParams.market || config.market, client_id: overrideParams.client_id || config.client_id, include: overrideParams.include || '', betOffers: overrideParams.betOffers || 'COMBINED', categoryGroup: overrideParams.categoryGroup || 'COMBINED', displayDefault: overrideParams.displayDefault || true }; if (noCache === true) { requestParams.nocache = Date.now(); } requestUrl += '?' + Object.keys(requestParams).map(function (k) { return encodeURIComponent(k) + '=' + encodeURIComponent(requestParams[k]); }).join('&amp;'); return coreLibrary.getData(requestUrl); } } }; × Search results Close "},"Module_statisticsModule.js.html":{"id":"Module_statisticsModule.js.html","title":"Source: Module/statisticsModule.js","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Source: Module/statisticsModule.js import coreLibrary from '../coreLibrary'; /** * Module to access statistics API * The statistics API has information concerning historical data of events (matches, competitions) * All methods in this module return Promises that are resolved when the data is ready and throws errors (that can be handled with .catch()) on failure * @module statisticsModule */ export default { /** * Configuration * @type {Object} * @property {String} baseApiUrl the baseURL for statistics API requests */ config: { baseApiUrl: 'https://api.kambi.com/statistics/api/' }, /** * Requests league table statistics data from api. * @param {String} filter a filter string to a competition. Example 'football/england/premier_league' * @returns {Promise} */ getLeagueTableStatistics (filter) { // Remove url parameters from filter filter = filter.match(/[^?]*/)[0]; // Removing trailing and starting slashes if present if ( filter[filter.length - 1] === '/' ) { filter = filter.slice(0, -1); } if ( filter[0] === '/' ) { filter = filter.slice(1); } return coreLibrary.getData(this.config.baseApiUrl + coreLibrary.config.offering + '/leaguetable/' + filter + '.json'); }, /** * Requests H2H statistics data from api. * @param {String|Number} eventId id of a match * @returns {Promise} */ getHeadToHeadStatistics (eventId) { return coreLibrary.getData(this.config.baseApiUrl + coreLibrary.config.offering + '/h2h/event/' + eventId + '.json'); }, /** * Requests TPI statistics data from api. * @param {String|Number} eventId id of a match * @returns {Promise} */ getTeamPerformanceStatistics (eventId) { return coreLibrary.getData(this.config.baseApiUrl + coreLibrary.config.offering + '/tpi/event/' + eventId + '.json'); } }; × Search results Close "},"Module_translationModule.js.html":{"id":"Module_translationModule.js.html","title":"Source: Module/translationModule.js","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Source: Module/translationModule.js import coreLibrary from '../coreLibrary'; /** * Module with internationalization methods * Provides a very simple internationalization mechanism * that is not relient in any library. * The loading of the right internationalization JSON file is handled automatically * @module translationModule */ export default { /** * fetched from the i18n folder JSON files. Only the current * locale strings are fetched * @type {Object} */ i18nStrings: {}, /** * Makes a request to fetch the provided locale strings * @param {String} locale Locale string, eg: sv_SE * @returns {Promise} * @private */ fetchTranslations (locale) { if (locale == null) { locale = 'en_GB'; } var self = this; var path = 'i18n/'; return new Promise((resolve, reject) =&gt; { coreLibrary.getData(path + locale + '.json') .then((response) =&gt; { this.i18nStrings = response; resolve(); }) .catch((error) =&gt; { if (locale !== 'en_GB') { console.debug('Could not load translations for ' + locale + ' falling back to en_GB'); self.fetchTranslations('en_GB').then(resolve); } else { console.debug('Could not load translations for en_GB'); console.trace(error); resolve(); } }); }); }, /** * Returns translated string based of a provided key. * @param {String} key Key to fetch translation for * @param {...String} args arguments to replace inside the translated string * @example * en_GB.json: * { &quot;welcomeUserToPlace&quot;: &quot;Welcome {0} to {1}&quot; } * Javascript: * getTranslation('welcomeUserToPlace', 'Daniel', 'Stadium') =&gt; 'Welcome Daniel to Stadium' * @returns {String} the localized string */ getTranslation: function (key, ...args) { if (this.i18nStrings[key] != null) { var str = this.i18nStrings[key]; for (var i = 0; i &lt; args.length; i++) { var replacement = args[i] || ''; str = str.replace('{' + i + '}', replacement); } return str; } return key; } }; × Search results Close "},"Module_utilModule.js.html":{"id":"Module_utilModule.js.html","title":"Source: Module/utilModule.js","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Source: Module/utilModule.js import translationModule from './translationModule'; import coreLibrary from '../coreLibrary'; /** * Module with utility functions * @module utilModule */ export default { /** * Util method for return unique items between arrays * @param {Array} A First array * @param {Array} B Second array * @returns {Array} * @private */ diffArray (A, B) { var map = {}, C = []; for (var i = B.length; i--;) { map[B[i]] = null; } // any other value would do for (var i = A.length; i--;) { if (!map.hasOwnProperty(A[i])) { C.push(A[i]); } } return C; }, /* Replaces expressions like &quot;{customer}&quot; from the provided string * to the value the have in the coreLibrary.config object * @param {String} str the string to replace the expressions in */ replaceConfigParameters (str) { if (str == null) { return str; } const config = coreLibrary.config; Object.keys(config).forEach((key) =&gt; { var regex = new RegExp('{' + key + '}', 'g'); var value = config[key]; str = str.replace(regex, value); }); return str; }, /** * Get decimal formatted odds. * @param {Number} odds Odds number * @returns {Number} */ getOddsDecimalValue (odds) { if (odds &lt; 100) { return odds.toFixed(2); } else if (odds &lt; 1000) { return odds.toFixed(1); } else { return odds.toFixed(0); } }, /** * Returns the outcome label translated. * @param {Object} outcome A betoffer outcome object * @param {Object} event Event object * @returns {string} */ getOutcomeLabel (outcome, event) { switch (outcome.type) { case 'OT_ONE': // Outcome has label 1. Applies to Threeway bet offers. return event.homeLabelCustom &amp;&amp; event.homeLabelCustom !== '' ? event.homeLabelCustom : event.homeName; case 'OT_CROSS': // Outcome has label X. Applies to Threeway bet offers. return translationModule.getTranslation('draw'); case 'OT_TWO': // Outcome has label 2. Applies to Threeway bet offers. return event.awayLabelCustom &amp;&amp; event.awayLabelCustom !== '' ? event.awayLabelCustom : event.awayName; case 'OT_OVER': // The “Over” outcome in Over/Under bet offer. return outcome.label + ' ' + (outcome.line / 1000); case 'OT_UNDER': // The “Under” outcome in Over/Under bet offer. return outcome.label + ' ' + (outcome.line / 1000); // Todo: Impelement these responses with translations // case 'OT_ODD': //The “Odd” outcome in Odd/Even bet offer. // break; // case 'OT_EVEN': //The “Even” outcome in Odd/Even bet offer. // break; // case 'OT_ONE_ONE': //1-1 outcome in Halftime/fulltime bet offer. // break; // case 'OT_ONE_TWO': //1-2 outcome in Halftime/fulltime bet offer. // break; // case 'OT_ONE_CROSS': //1-X outcome in Halftime/fulltime bet offer. // break; // case 'OT_TWO_ONE': //2-1 outcome in Halftime/fulltime bet offer. // break; // case 'OT_TWO_TWO': //2-2 outcome in Halftime/fulltime bet offer. // break; // case 'OT_TWO_CROSS': //2-X outcome in Halftime/fulltime bet offer. // break; // case 'OT_CROSS_ONE': //X-1 outcome in Halftime/fulltime bet offer. // break; // case 'OT_CROSS_TWO': //X-2 outcome in Halftime/fulltime bet offer. // break; // case 'OT_CROSS_CROSS': //X-X outcome in Halftime/fulltime bet offer. // break; // case 'OT_ONE_OR_TWO': //1 or 2 outcome in Double Chance bet offer. // break; // case 'OT_ONE_OR_CROSS': //1 or X outcome in Double Chance bet offer. // break; // case 'OT_CROSS_OR_TWO': //X or 2 outcome in Double Chance bet offer. // break; // case 'OT_YES': //“Yes” outcome in Head To Head and Yes/No bet offer. // break; // case 'OT_NO': //“No” outcome in Head To Head and Yes/No bet offer. // break; // case 'OT_OTHER': //“Other results” outcome in Result bet offer. // break; // case 'OT_UNTYPED': //Outcome does not have type. // break; // case 'OT_WC_HOME': //Outcome has label Home Win. Applies to WinCast bet offers. // break; // case 'OT_WC_DRAW': //Outcome has label Draw. Applies to WinCast bet offers. // break; // case 'OT_WC_AWAY': //Outcome has label Away Win. Applies to WinCast bet offers. // break; default: console.warn('Unhandled outcome type: ' + outcome.type, outcome); return outcome.label; } } }; × Search results Close "},"Module_widgetModule.js.html":{"id":"Module_widgetModule.js.html","title":"Source: Module/widgetModule.js","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Source: Module/widgetModule.js /** * Module with methods to manipulate the widget and interact with the sportsbook * @module widgetModule */ import utilModule from './utilModule'; import coreLibrary from '../coreLibrary'; export default { /** * Widget API object * @type {object} * @private */ api: { // placeholders for when running outside of the sportsbook requestSetup () { }, request () { }, set () { }, remove () { }, createUrl () { }, createFilterUrl (terms, urlBase) { urlBase = urlBase || 'filter'; var segments = terms.filter(term =&gt; term.indexOf('/') === 0) .reduce((segments, term) =&gt; { var coords = []; term.replace(/\\/+$/, '').split('/').slice(1).forEach((termKey, i) =&gt; { if (!(i in segments)) { segments[i] = []; } var pointer = segments[i]; if (i &gt; 0) { coords.forEach((coord) =&gt; { for (var j = 0; j &lt;= coord; j++) { if (pointer[j] == null) { pointer.push(j === coord ? [] : 'all'); } } pointer = pointer[coord]; }); } if (pointer.indexOf(termKey) === -1) { pointer.push(termKey); } coords[i] = pointer.length - 1; return coords[i]; }); return segments; }, []); var route = '#' + urlBase.replace(/.*?#/, '').replace(/^\\//, ''); route += segments.reduce((str, segment) =&gt; str + '/' + JSON.stringify(segment).slice(1, -1), '') .replace(/&quot;/g, '') .replace(/(,all)+(\\/|]|$)/g, '$2'); for (var i = 0; i &lt;= segments.length; i++) { route = route.replace(/\\[([^,\\]]*)]/g, '$1'); } var attributes = terms.filter(term =&gt; term.indexOf('/') !== 0).join(','); if (attributes) { for (var j = 0; j &lt; 4 - segments.length; j++) { route += '/all'; } route += '/' + attributes; } return route.match(/filter$/) ? route + '/all' : route; } }, /** * Object in which you can add event listeners for Kambi Widget API events * Valid events listeners: * * 'WIDGET:HEIGHT': Widget height changed * * 'OUTCOME:REMOVED:{outcomeId}': Outcome with {outcomeId} removed * * 'OUTCOME:ADDED:{outcomeId}': Outcome with {outcomeId} added * * 'OUTCOME:UPDATE:{outcomeId}': Outcome with {outcomeId} updated * * 'WIDGET:ARGS': Widget args changed * * 'PAGE:INFO': Page info changed * * 'ODDS:FORMAT': Odds format changed * * 'CLIENT:CONFIG': Client config changed * * 'USER:LOGGED_IN': User logged in changed * * @example * * widgetModule.events * .subscribe('OUTCOME:ADDED:' + outcome.id, * ( data ) =&gt; { * ... * }); * * @type {Object} * @property {Function} subscribe Parameters: (eventName, eventHandlerFn). Subscribes to the eventName, when that event happens eventHandlerFn is called * @property {Function} unsubscribe Parameters: (eventName, eventHandlerFn). Unsubscribes all handlers to the event or if an eventHandlerFn is passed, only unsubscribes that handler */ events: (function() { /** * Map of events with handlers * @type {object&lt;string, function[]&gt;} */ const handlers = {}; /** * Subscribes a handler to given event. * @param {string} event Event name * @param {function} handler Handler function */ const subscribe = function(event, handler) { if (handlers.hasOwnProperty(event)) { handlers[event].push(handler); } else { handlers[event] = [handler]; } }; /** * Unsubscribes handler/all handlers from given event. * @param {string} event Event name * @param {function?} handler Optional handler function pointer */ const unsubscribe = function(event, handler) { if (handlers.hasOwnProperty(event)) { // remove all handlers for given event if (!handler) { handlers[event] = []; return; } // remove particular handler const handlerIdx = handlers[event].indexOf(handler); if (handlerIdx &gt; -1) { handlers[event].splice(handlerIdx, 1); } } }; /** * Emits an event with given arguments. * @param {string} event Event name * @param {...*} args Arguments for handlers * @private */ const publish = function(event, ...args) { if (!handlers.hasOwnProperty(event)) { return; } handlers[event].forEach(handler =&gt; handler.apply(undefined, args)); }; // api return { subscribe, unsubscribe, publish }; })(), /** * Stores all the betslip outcome ids we are watching * to trigger events * @type {array} * @private */ betslipIds: [], /** * Handles widget api response. * Emits events for each response * @param {Object} response * @private */ handleResponse (response) { switch (response.type) { case this.api.WIDGET_HEIGHT: // We've received a height response this.events.publish('WIDGET:HEIGHT', response.data); break; case this.api.BETSLIP_OUTCOMES: // We've received a response with the outcomes currently in the betslip var i = 0, len = response.data.outcomes.length; var updateIds = []; // Gather all the ids in the betslip in one array for (; i &lt; len; ++i) { updateIds.push(response.data.outcomes[i].id); } // Diff against what the coreLibrary already has stored so we know what was added and what was removed var removedIds = utilModule.diffArray(this.betslipIds, updateIds); var addedIds = utilModule.diffArray(updateIds, this.betslipIds); // Save the updated ids this.betslipIds = updateIds; // Emit events for each removed id i = 0; len = removedIds.length; for (; i &lt; len; ++i) { this.events.publish('OUTCOME:REMOVED:' + removedIds[i]); } // Emit events for each added id i = 0; len = addedIds.length; for (; i &lt; len; ++i) { this.events.publish('OUTCOME:ADDED:' + addedIds[i]); } // Emit a generic update in case we want to use that this.events.publish('OUTCOMES:UPDATE', response.data); break; case this.api.WIDGET_ARGS: // We've received a response with the arguments set in the coreLibrary.args = response.data; this.events.publish('WIDGET:ARGS', response.data); break; case this.api.PAGE_INFO: // Received page info response coreLibrary.setPageInfo(response.data); this.events.publish('PAGE:INFO', response.data); break; case this.api.CLIENT_ODDS_FORMAT: // Received odds format response coreLibrary.setOddsFormat(response.data); this.events.publish('ODDS:FORMAT', response.data); break; case this.api.CLIENT_CONFIG: coreLibrary.setConfig(response.data); this.events.publish('CLIENT:CONFIG', response.data); break; case this.api.USER_LOGGED_IN: console.debug('User logged in', response.data); this.events.publish('USER:LOGGED_IN', response.data); break; case 'Setup': this.events.publish('Setup response', response.data); break; default: // Unhandled response console.info('Unhandled response type: ' + response.type); console.info(response); break; } }, /** * Creates url from given path and optionalRoot * @param {String} path * @param {String} optionalRoot * @returns {String} */ createUrl (path, optionalRoot) { return this.api.createUrl(path, optionalRoot); }, /** * Creates a filter url from given array * @example * destination = ['/football/europa_league/', '/football/world_cup_qualifying_-_europe/']; * @param {Array} destination * @returns {string} */ createFilterUrl (destination) { return this.api.createFilterUrl(destination, coreLibrary.config.routeRoot); }, /** * Returns the page type page type * @returns {String} */ getPageType () { if (!coreLibrary.pageInfo.pageType) { return ''; } var pageType = coreLibrary.pageInfo.pageType; switch (pageType) { case 'event': return ''; case 'event-live': return 'live/'; default: console.info('Unknown page type: ' + pageType); break; } }, /** * Makes widget api request for setupdata * @param {fn} callback Callback */ requestSetup (callback) { this.api.requestSetup(callback); }, /** * Requests widget height from widget api */ requestWidgetHeight () { this.api.request(this.api.WIDGET_HEIGHT); }, /** * Set widget iframe height * @param {Number} height the height in pixels */ setWidgetHeight (height) { this.api.set(this.api.WIDGET_HEIGHT, height); }, /** * tries to adapt the widget iframe height to match the content * * Only works if the html and body tags don't have height: 100% styling rule */ adaptWidgetHeight () { // tries to adapt the widget iframe height to match the content var body = document.body, html = document.documentElement; var height = Math.max(body.offsetHeight, html.scrollHeight, html.offsetHeight); this.api.set(this.api.WIDGET_HEIGHT, height); }, /** * Enables/disables animations of changing the height of the iframe * @param {boolean} enableTransition new state to be */ enableWidgetTransition (enableTransition) { if (enableTransition) { this.api.set(this.api.WIDGET_ENABLE_TRANSITION); } else { this.api.set(this.api.WIDGET_DISABLE_TRANSITION); } }, /** * Call api to remove widget from the sportsbook */ removeWidget () { this.api.remove(); }, /** * Method to navigate to a live event page * @param {number} eventId */ navigateToLiveEvent (eventId) { this.navigateClient('event/live/' + eventId); }, /** * Method to navigate to a pre-live event page * @param {number} eventId */ navigateToEvent (eventId) { this.navigateClient('event/' + eventId); }, /** * Method to navigate to a filter page * @param {String} filterParams */ navigateToFilter (filterParams) { if (typeof filterParams === 'string' &amp;&amp; filterParams.indexOf('filter/') === -1) { filterParams = 'filter/' + filterParams; } this.navigateClient(filterParams); }, /** * Navigates to the live events page */ navigateToLiveEvents () { this.navigateClient(['in-play']); }, /** * Adds an outcomes to the betslip * @param {Array&lt;Number&gt;|Number} outcomes ids of the outcomes to add * @param {Array&lt;Number&gt;|Number} stakes the value of the stakes to add (referencing the ids in the outcomes parameter) * @param {String} updateMode defaults to 'append', but also accepts 'replace' * @param {String} source */ addOutcomeToBetslip (outcomes, stakes, updateMode, source) { var arrOutcomes = []; // Check if the outcomes parameter is an array and add it, otherwise add the the single value as an array if (Array.isArray(outcomes)) { arrOutcomes = outcomes; } else { arrOutcomes.push(outcomes); } // Setup the data object to be sent to the widget API var data = { outcomes: arrOutcomes }; // Check if we got any stakes passed to use, add them to the data object if so if (stakes != null) { if (Array.isArray(stakes)) { data.stakes = stakes; } else { data.stakes = [stakes]; } } // Set the coupon type, defaults to TYPE_SINGLE data.couponType = arrOutcomes.length === 1 ? this.api.BETSLIP_OUTCOMES_ARGS.TYPE_SINGLE : this.api.BETSLIP_OUTCOMES_ARGS.TYPE_COMBINATION; // Set the update mode, defaults to UPDATE_APPEND data.updateMode = updateMode !== 'replace' ? this.api.BETSLIP_OUTCOMES_ARGS.UPDATE_APPEND : this.api.BETSLIP_OUTCOMES_ARGS.UPDATE_REPLACE; if (source != null) { data.source = source; } // Add tracking name if it's set if (coreLibrary.widgetTrackingName != null) { data.name = coreLibrary.widgetTrackingName; } // Send the data to the widget this.api this.api.set(this.api.BETSLIP_OUTCOMES, data); }, /** * Removes outcomes from betslip * @param {Array&lt;Number&gt;|Number} outcomes ids of the outcomes to remove form the betslip */ removeOutcomeFromBetslip (outcomes) { var arrOutcomes = []; if (Array.isArray(outcomes)) { arrOutcomes = outcomes; } else { arrOutcomes.push(outcomes); } var data = { outcomes: arrOutcomes }; // Add tracking name if it's set if (coreLibrary.widgetTrackingName != null) { data.name = coreLibrary.widgetTrackingName; } this.api.set(this.api.BETSLIP_OUTCOMES_REMOVE, data); }, /** * Requests betslip outcomes */ requestBetslipOutcomes () { this.api.request(this.api.BETSLIP_OUTCOMES); }, /** * Requests page info */ requestPageInfo () { this.api.request(this.api.PAGE_INFO); }, /** * Requests widget args */ requestWidgetArgs () { this.api.request(this.api.WIDGET_ARGS); }, /** * Requests client config */ requestClientConfig () { this.api.request(this.api.CLIENT_CONFIG); }, /** * Requests odds format */ requestOddsFormat () { this.api.request(this.api.CLIENT_ODDS_FORMAT); }, /** * Requests american odds * @param {Number} odds * @returns {Promise} */ requestOddsAsAmerican (odds) { return new Promise((resolve) =&gt; { this.api.requestOddsAsAmerican(odds, (americanOdds) =&gt; { resolve(americanOdds); }); }); }, /** * Requests fractional odds * @param {Number} odds * @returns {Promise} */ requestOddsAsFractional (odds) { return new Promise((resolve) =&gt; { this.api.requestOddsAsFractional(odds, (fractionalOdds) =&gt; { resolve(fractionalOdds); }); }); }, /** * Navigates to a page in the sportsbook * @param {String|Array} destination fragment part of the URL to navigate to (the part after the # in the URL) */ navigateClient (destination) { var finalTarget = ''; if (typeof destination === 'string') { finalTarget = '#' + coreLibrary.config.routeRoot + destination; } else if (Array.isArray(destination)) { finalTarget = this.api.createFilterUrl(destination, coreLibrary.config.routeRoot); } if (coreLibrary.widgetTrackingName != null) { this.api.navigateClient(finalTarget, coreLibrary.widgetTrackingName); } else { this.api.navigateClient(finalTarget); } } }; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Modules × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Tutorials × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components widget-core-libraryCollection of methods and settings common to all widgets, contains the initial communication with KambiWidgetApi and support for i18n. × Search results Close "},"module-coreLibrary.html":{"id":"module-coreLibrary.html","title":"Module: coreLibrary","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Module: coreLibrary Main module that holds the other modules as well as widgetrelated configurations Source: coreLibrary.js, line 7 Members &lt;static&gt; browser :String Name of the browser that is running the widget Type: String Source: coreLibrary.js, line 108 &lt;static&gt; browserVersion :String Browser version Type: String Source: coreLibrary.js, line 114 &lt;static&gt; cssLoadedPromise :Promise Promise that is resolved when all the CSS has finished loading Type: Promise Source: coreLibrary.js, line 367 &lt;static&gt; kambiDefaultClasses An array with the default classes that should be added to HTML tag Source: coreLibrary.js, line 162 &lt;inner&gt; apiVersions :Object Versions of the API provided by the sportsbook Type: Object Properties: Name Type Description client String libs String wapi String Source: coreLibrary.js, line 329 &lt;inner&gt; args args object for the widget, merges the default args provided by coreLibrary.init() with the ones that come from the sportsbook. There are some pre-defined arguments that all widgets accept, but most of them are widget-defined. Properties: Name Type Description customCssUrl String URL to a CSS file to add to the page, expressions like &quot;{customer}&quot; are replaced with their values in coreLibrary.config. This is useful to load different stylesheets based on operator name. Example: Say coreLibrary.config.customer is 'kambi', then if this argument was set: { customCssUrl: &quot;https://someurl.com/customcss/{customer}/style.css&quot; } It would load this CSS file and add it to the page: https://someurl.com/customcss/kambi/style.css customCssUrlFallback String fallback if the fetching of customCssUrl fails conditionalArgs Array.&lt;Object&gt; Optional, specify arguments to be applied based on some condition based in the values inside coreLibrary.config or coreLibrary.pageInfo example: conditionalArgs: [ // if coreLibrary.config.currency is 'EUR' apply { euro: true, dollars: false } to the arguments { config: { currency: 'EUR' }, args: { euro: true, dollars: false } }, // if market is 'IT' AND offering is 'IT' apply { italian: true } to the arguments { config: { market: 'IT', offering: 'IT' }, args: { italian: true } }, ] Source: coreLibrary.js, line 214 &lt;inner&gt; config :Object Config object. This data comes from the sportsbook and should not be manually changed. When in running the widget stand alone this values are retrieved from ./src/mockSetupData.json Type: Object Properties: Name Type Description apiBaseUrl String url of the offering api to use auth Boolean channelId Number currency String what currency to use customer String the customer to use with the offering API device String what kind of device does the user have. Possible values: 'desktop', 'mobile' locale String locale of the user, example: 'en_GB', 'sv_SE' market String market to use with the offering API. oddsFormat String the odds format to show. Possible values: 'decimal', 'fractional', 'american'. To listen to changes to this value use widgetModule.events.subscribe('ODDS:FORMAT', eventHandlerFn); offering String the offering to use with the offering API routeRoot String streamingAllowedForPlayer Boolean client_id Number version String Source: coreLibrary.js, line 123 &lt;inner&gt; pageInfo :Object Information about the page that the widget is being loaded from Type: Object Properties: Name Type Description leaguePaths Array(String) array with league paths. Example:['football/england/premier_league'] pageParam String parameter for this page. For a page of type 'filter' an example would be 'football/england/premier_league' pageTrackingPath String the path in the url for this page. For example: '/filter/football/england/premier_league' pageType String type of the page, examples: 'home', 'filter' Source: coreLibrary.js, line 299 Methods &lt;static&gt; addClasses(classes) Adds classes to to HTML tag Parameters: Name Type Description classes Array An array of strings with the classnames to be addes Source: coreLibrary.js, line 525 &lt;static&gt; getData(url) Makes a ajax request and parses its response as JSON Parameters: Name Type Description url String Source: coreLibrary.js, line 587 Returns: resolved when the data fetching finishes. If an error happens during fetching the error can be catched in a .catch() function Type Promise &lt;static&gt; getFile(url) Makes an ajax request and returns the response body as text Parameters: Name Type Description url String Source: coreLibrary.js, line 605 Returns: resolved when the data fetching finishes. If an error happens during fetching the error can be catched in a .catch() function Type Promise &lt;static&gt; init(defaultArgs) Initializes the Kambi apiUses ./src/mockSetupData.json as coreLibrary.configs if not loaded inside the sportsbook (ie opened the widget directly). Parameters: Name Type Description defaultArgs Object arguments to be used if they are not provided by the sportsbook Source: coreLibrary.js, line 375 Returns: resolved when everything is ready. If an error happens during fetching the error can be catched in a .catch() function Type Promise &lt;static&gt; setWidgetTrackingName(name) Sets widget tracking name for analytics purposes. This tracking name is used for calls to add bets to the betslip Parameters: Name Type Description name String The name to use Source: coreLibrary.js, line 620 × Search results Close "},"module-offeringModule.html":{"id":"module-offeringModule.html","title":"Module: offeringModule","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Module: offeringModule Module with methods to request data from the offering APIThe offering API has information concerning events (matches, competations) and their respective betoffers as well as live data if availableAll methods in this module return Promises that are resolved when the data is ready and throws errors (that can be handled with .catch()) on failure Source: Module/offeringModule.js, line 3 Methods &lt;static&gt; doRequest(requestPath, params, version, noCache) Makes a request to provided path setting the appropriated URL parameters. Usually this method should not be called directly, unless you want to access an endpoint that is not available in the other methods The final url looks like: coreLibrary.config.apiBaseUrl + version + coreLibrary.config.offering + requestPath Example (same as calling offeringModule.getLiveEvents() but forcing to use Portugal Portuguese locale) doRequest('/event/live/open.json' { lang: 'pt_PT' }); this call would fetch this url: https://api.kambi.com/offering/api/v2/kambi/event/live/open.json?lang=pt_PT&amp;market=kambi&amp;client_id=2&amp;include=&amp;betOffers=COMBINED&amp;categoryGroup=COMBINED&amp;displayDefault=true&amp;nocache=1476973932524 Parameters: Name Type Description requestPath string the path to the request params object params to use, can override the parameters this method usually sets version number | string which version of the API to use. Some endpoints are 'v2' and some are 'v3' noCache boolean if true will add a cache-busting URL parameter. Defaults to true Source: Module/offeringModule.js, line 245 Returns: Type Promise &lt;static&gt; getEvent(eventId) Requests and event from api Parameters: Name Type Description eventId String The event id we need to fetch Source: Module/offeringModule.js, line 193 Returns: Type Promise &lt;static&gt; getEventsByFilter(filter, params) Get events by filter, only returns the main betoffer for the event. To get all betoffers use getEvent() or getLiveEvent() Parameters: Name Type Description filter String Filter string, eg: football params Object Request relevant parameters Source: Module/offeringModule.js, line 38 Returns: Type Promise &lt;static&gt; getGroup(groupId) Get group information. Parameters: Name Type Description groupId Number | String Group id Source: Module/offeringModule.js, line 27 Returns: Type Promise &lt;static&gt; getGroupEvents(groupId) Get group events Parameters: Name Type Description groupId number | string Group id Source: Module/offeringModule.js, line 17 Returns: Type Promise &lt;static&gt; getHighlight() Request the highlight resource which is what is shown under the &quot;Popular&quot; section in the Sportsbook Source: Module/offeringModule.js, line 210 Returns: Type Promise &lt;static&gt; getLiveEvent(eventId) Returns a live event Parameters: Name Type Description eventId Number | String The event id we need to fetch Source: Module/offeringModule.js, line 134 Returns: Type Promise &lt;static&gt; getLiveEventsByFilter(filter) Get live events by filter, only returns the main betoffer for the event. To get all betoffers use getEvent() or getLiveEvent() Parameters: Name Type Description filter String Filter string Source: Module/offeringModule.js, line 153 Returns: Type Promise × Search results Close "},"module-statisticsModule.html":{"id":"module-statisticsModule.html","title":"Module: statisticsModule","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Module: statisticsModule Module to access statistics APIThe statistics API has information concerning historical data of events (matches, competitions)All methods in this module return Promises that are resolved when the data is ready and throws errors (that can be handled with .catch()) on failure Source: Module/statisticsModule.js, line 3 Members &lt;static&gt; config :Object Configuration Type: Object Properties: Name Type Description baseApiUrl String the baseURL for statistics API requests Source: Module/statisticsModule.js, line 17 Methods &lt;static&gt; getHeadToHeadStatistics(eventId) Requests H2H statistics data from api. Parameters: Name Type Description eventId String | Number id of a match Source: Module/statisticsModule.js, line 45 Returns: Type Promise &lt;static&gt; getLeagueTableStatistics(filter) Requests league table statistics data from api. Parameters: Name Type Description filter String a filter string to a competition. Example 'football/england/premier_league' Source: Module/statisticsModule.js, line 26 Returns: Type Promise &lt;static&gt; getTeamPerformanceStatistics(eventId) Requests TPI statistics data from api. Parameters: Name Type Description eventId String | Number id of a match Source: Module/statisticsModule.js, line 54 Returns: Type Promise × Search results Close "},"module-translationModule.html":{"id":"module-translationModule.html","title":"Module: translationModule","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Module: translationModule Module with internationalization methodsProvides a very simple internationalization mechanismthat is not relient in any library.The loading of the right internationalization JSON file is handled automatically Source: Module/translationModule.js, line 3 Members &lt;static&gt; i18nStrings :Object fetched from the i18n folder JSON files. Only the currentlocale strings are fetched Type: Object Source: Module/translationModule.js, line 16 Methods &lt;static&gt; getTranslation(key, args) Returns translated string based of a provided key. Parameters: Name Type Argument Description key String Key to fetch translation for args String &lt;repeatable&gt; arguments to replace inside the translated string Source: Module/translationModule.js, line 60 Returns: the localized string Type String Example en_GB.json: { &quot;welcomeUserToPlace&quot;: &quot;Welcome {0} to {1}&quot; } Javascript: getTranslation('welcomeUserToPlace', 'Daniel', 'Stadium') =&gt; 'Welcome Daniel to Stadium' × Search results Close "},"module-utilModule.html":{"id":"module-utilModule.html","title":"Module: utilModule","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Module: utilModule Module with utility functions Source: Module/utilModule.js, line 4 Methods &lt;static&gt; getOddsDecimalValue(odds) Get decimal formatted odds. Parameters: Name Type Description odds Number Odds number Source: Module/utilModule.js, line 54 Returns: Type Number &lt;static&gt; getOutcomeLabel(outcome, event) Returns the outcome label translated. Parameters: Name Type Description outcome Object A betoffer outcome object event Object Event object Source: Module/utilModule.js, line 70 Returns: Type string × Search results Close "},"module-widgetModule.html":{"id":"module-widgetModule.html","title":"Module: widgetModule","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components Module: widgetModule Module with methods to manipulate the widget and interact with the sportsbook Source: Module/widgetModule.js, line 1 Members &lt;static&gt; events :Object Object in which you can add event listeners for Kambi Widget API eventsValid events listeners: 'WIDGET:HEIGHT': Widget height changed 'OUTCOME:REMOVED:{outcomeId}': Outcome with {outcomeId} removed 'OUTCOME:ADDED:{outcomeId}': Outcome with {outcomeId} added 'OUTCOME:UPDATE:{outcomeId}': Outcome with {outcomeId} updated 'WIDGET:ARGS': Widget args changed 'PAGE:INFO': Page info changed 'ODDS:FORMAT': Odds format changed 'CLIENT:CONFIG': Client config changed 'USER:LOGGED_IN': User logged in changed Type: Object Properties: Name Type Description subscribe function Parameters: (eventName, eventHandlerFn). Subscribes to the eventName, when that event happens eventHandlerFn is called unsubscribe function Parameters: (eventName, eventHandlerFn). Unsubscribes all handlers to the event or if an eventHandlerFn is passed, only unsubscribes that handler Source: Module/widgetModule.js, line 121 Example widgetModule.events .subscribe('OUTCOME:ADDED:' + outcome.id, ( data ) =&gt; { ... }); Methods &lt;static&gt; adaptWidgetHeight() tries to adapt the widget iframe height to match the content Only works if the html and body tags don't have height: 100% styling rule Source: Module/widgetModule.js, line 336 &lt;static&gt; addOutcomeToBetslip(outcomes, stakes, updateMode, source) Adds an outcomes to the betslip Parameters: Name Type Description outcomes Array.&lt;Number&gt; | Number ids of the outcomes to add stakes Array.&lt;Number&gt; | Number the value of the stakes to add (referencing the ids in the outcomes parameter) updateMode String defaults to 'append', but also accepts 'replace' source String Source: Module/widgetModule.js, line 405 &lt;static&gt; createFilterUrl(destination) Creates a filter url from given array Parameters: Name Type Description destination Array Source: Module/widgetModule.js, line 284 Returns: Type string Example destination = ['/football/europa_league/', '/football/world_cup_qualifying_-_europe/']; &lt;static&gt; createUrl(path, optionalRoot) Creates url from given path and optionalRoot Parameters: Name Type Description path String optionalRoot String Source: Module/widgetModule.js, line 273 Returns: Type String &lt;static&gt; enableWidgetTransition(enableTransition) Enables/disables animations of changing the height of the iframe Parameters: Name Type Description enableTransition boolean new state to be Source: Module/widgetModule.js, line 348 &lt;static&gt; getPageType() Returns the page type page type Source: Module/widgetModule.js, line 292 Returns: Type String &lt;static&gt; navigateClient(destination) Navigates to a page in the sportsbook Parameters: Name Type Description destination String | Array fragment part of the URL to navigate to (the part after the # in the URL) Source: Module/widgetModule.js, line 532 &lt;static&gt; navigateToEvent(eventId) Method to navigate to a pre-live event page Parameters: Name Type Description eventId number Source: Module/widgetModule.js, line 375 &lt;static&gt; navigateToFilter(filterParams) Method to navigate to a filter page Parameters: Name Type Description filterParams String Source: Module/widgetModule.js, line 383 &lt;static&gt; navigateToLiveEvent(eventId) Method to navigate to a live event page Parameters: Name Type Description eventId number Source: Module/widgetModule.js, line 367 &lt;static&gt; navigateToLiveEvents() Navigates to the live events page Source: Module/widgetModule.js, line 394 &lt;static&gt; removeOutcomeFromBetslip(outcomes) Removes outcomes from betslip Parameters: Name Type Description outcomes Array.&lt;Number&gt; | Number ids of the outcomes to remove form the betslip Source: Module/widgetModule.js, line 450 &lt;static&gt; removeWidget() Call api to remove widget from the sportsbook Source: Module/widgetModule.js, line 359 &lt;static&gt; requestBetslipOutcomes() Requests betslip outcomes Source: Module/widgetModule.js, line 470 &lt;static&gt; requestClientConfig() Requests client config Source: Module/widgetModule.js, line 491 &lt;static&gt; requestOddsAsAmerican(odds) Requests american odds Parameters: Name Type Description odds Number Source: Module/widgetModule.js, line 507 Returns: Type Promise &lt;static&gt; requestOddsAsFractional(odds) Requests fractional odds Parameters: Name Type Description odds Number Source: Module/widgetModule.js, line 520 Returns: Type Promise &lt;static&gt; requestOddsFormat() Requests odds format Source: Module/widgetModule.js, line 498 &lt;static&gt; requestPageInfo() Requests page info Source: Module/widgetModule.js, line 477 &lt;static&gt; requestSetup(callback) Makes widget api request for setupdata Parameters: Name Type Description callback fn Callback Source: Module/widgetModule.js, line 312 &lt;static&gt; requestWidgetArgs() Requests widget args Source: Module/widgetModule.js, line 484 &lt;static&gt; requestWidgetHeight() Requests widget height from widget api Source: Module/widgetModule.js, line 319 &lt;static&gt; setWidgetHeight(height) Set widget iframe height Parameters: Name Type Description height Number the height in pixels Source: Module/widgetModule.js, line 327 × Search results Close "},"tutorial-1 - Introduction.html":{"id":"tutorial-1 - Introduction.html","title":"Tutorial: 1 - Introduction","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components 1 - Introduction Widgets are self-contained content that can be added to various places in the Kambi client. It provides the possibility for the operator to differentiate the client, to add unique features or content, and to tailor the client to a group of players, or even to individuals. The widget is an html-page loaded inside an iframe. By configuration using JavaScript the operator controls what widgets to load, where to place them and when to display them. Pre-requisites Install Nodejs latest version Run: npm install -g kambi-widget-build-tools By running this command you will now have a new command line tool called kambi-widgets-cli which is used for creating new projects Notes: By installing Nodejs you should have the npm command line tool installed. Make sure that the version of npm you have is 3.0.0 or higher by running: npm --version Version 3.0.0 of npm is included in Nodejs versions 5.0.0 or higher. Creating a New Project Run: kambi-widgets-cli init project-name This process can take a few minutes to download all the dependencies. A new project will be created inside the project-name folder. This project has a very simple example on how to build a widget. Setup an Existing Project Clone the project repository Inside the project folder run: npm install This process can take a few minutes to download all the dependencies. Running the Project in Development Mode Inside the project folder run: npm run start If the build was successful the widget will be running under https://localhost:8080 after a few seconds. The server that hosts the widgets code runs under port 8080 and under the HTTPS protocol with a self-signed certificate, which means you might get an HTTPS certificate error unless you trust the certificate. See the section 2 - Development for more information. Building a Project for Production Inside the project folder run: npm run build If the build was successful after a few seconds the widgets code will be bundled inside the /dist/ folder. All files of this folder should be deployed to whatever hosting solution you use. The sportsbook needs to point to the index.html file from this folder. See section 3 - Production Builds and Deployment for more information × Search results Close "},"tutorial-2 - Development.html":{"id":"tutorial-2 - Development.html","title":"Tutorial: 2 - Development","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components 2 - Development Running the widget Inside the project folder run: npm run start If the build was successful the widget will be running under https://localhost:8080 after a few seconds. The server that hosts the widgets code runs under port 8080 To open the widget inside the Sportsbook while in development configure the widgetSettings to point to to https://localhost:8080/ The server runs under the HTTPS protocol, so in order to see the widget inside the sportsbook it is required to trust the self-signed certificate that the development server uses. See next section for more information. HTTPS certificatenpm run start starts a built-in webserver (called WebpackDevServer) that hosts the widgets code for development mode. This servers runs under the HTTPS protocol because that is required by the Kambi Sportsbook, as such it has a self-signed certificate which needs to be manually trusted in order to be able to open the widget. In Chrome and Firefox you can trust the certificate by visiting https://localhost:8080 and hitting advance to accept the certificate. For Microsoft Edge and Internet explorer you need to add the certificate on Windows: Open control panel Open Internet options Select content tab Click on Certificates Select Trusted Root Certification Authorities Clici import Select the certificate from project-folder\\node_modules\\webpack-dev-server\\ssl\\server.crt Project file structureproject README.md .eslintrc .gitignore .editorconfig LICENSE package.json dist node_modules src app.scss index.html index.js mockSetupData.json i18n en_GB.json README.md Readme for the project .eslintrc, .gitignore, .editorconfig Configuration files for the project. These files are overwritten everytime the widget is built to make sure that all the widgets have the same files LICENSE License file of the project package.json NPM configuration file. This file lists metadata about the project as well as all external dependencies it uses dist When building the project for production with npm run build the files to be deployed are placed inside this folder node_modules All NPM dependencies used in the project are stored in this folder, if the project seems to be missing or using outdated dependencies delete this folder and run npm install to download fresh versions of all the dependencies src This folder holds the source code for the widget src/app.scss SCSS file with styling rules for this widget, this file is converted to regular CSS which is then included in the page during the build process. SCSS is a superset of CSS and as such all CSS is also valid SCSS, so normal CSS can be placed in this file. More information on SCSS here src/index.html The markup of the widget, ideally the widget should only change the &lt;body&gt; section of this file. Additional files/libraries should not be included in as &lt;script&gt; tags in the page, instead they should be included by importing them inside index.js, although it is still possible to do so. See the following sections on how to add dependencies to the project src/index.js This is the main javascript file of the project, see the following sections on how to use it src/mockSetupData.json This file is used ONLY when opening the widget OUTSIDE of the Kambi Sportsbook (that means accessing https://localhost:8080/ directly), it mocks values that would normally be passed by the Sportsbook to the widget. By changing values in this file you can test how the widget will look like and behave in different configurations, for example in another language. For more information check the API documentation for coreLibrary.config, coreLibrary.args and coreLibrary.pageInfo src/i18nThis folder holds all the internationalization JSON files of the widget, these are used by the translationModule, the use of these files are optional if no internationalization is required. If the user locale is not found in this folder it will fallback to en_GB.json. These are all the currently supported locales in the Sportsbook, although they can vary by operator: cs_CZ.json, de_DE.json, es_ES.json, fr_CH.json, lt_LT.json, no_NO.json, ro_RO.json, da_DK.json, el_GR.json, et_EE.json, fr_FR.json, lv_LV.json, pl_PL.json, ru_RU.json, de_AT.json, en_AU.json, fi_FI.json, hu_HU.json, nl_BE.json, pt_BR.json, sv_SE.json, de_CH.json, en_GB.json, fr_BE.json, it_IT.json, nl_NL.json, pt_PT.json, tr_TR.json Core Library and Build ToolsBy default the a widget project uses these two dependencies: kambi-widget-core-library Has API methods for interacting with the Sportsbook and fetching data as well as methods for internationalization. kambi-widget-build-tools Defines the build process of the widget as well as the built-in development server. Only used at build time. These dependencies are external to the project and as such have their own specific versions, you can check their versions inside the package.json file. Importing and Exporting FilesThe widget uses webpack to transpile, minify, concatenate, bundle all the files and their dependencies together. This is all done automatically by the scripts npm run start (which also starts a webserver for development) and npm run build. All the webpack configuration is already done by those scripts and as such no configuration is required by the user. However the way that the files are bundled together requires them to be referenced in order for them to be included in the final bundle. The entry point of the application is src/index.js, this file needs to reference (import) directly or indirectly all other files used, this means even HTML and CSS files. The template project that is generated by kambi-widgets-cli init shows this: import { coreLibrary, widgetModule, offeringModule } from 'kambi-widget-core-library'; import './index.html'; import './app.scss'; ...As can be seen here, that file imports coreLibrary, widgetModule and offeringModule from kambi-widget-core-library as well as importing the ./index.html and ./app.scss. If those files were not imported they would not be included in the final bundled version (index.html would be missing in the dist folder for example). Imports that start with ./ mean that they are importing other files in the same project, while those without ./ are importing files that are dependencies of the project (see next few sections for more information). So it is possible to split the widgets code in multiple javascript files. More information about exports and imports can be seen here and here Basic Code SetupAll widgets need to start by calling coreLibrary.init() and passing it the default arguments that the widget receives. These arguments can be overwritten by the Sportsbook (or inside src/mockSetupData.json arguments attribute when running the widget outside the sportsbook). coreLibrary.init() returns a Promise object which is a way to deal with asynchronous requests (all calls to fetch data in kambi-widget-core-library return Promises). You can learn more about Promises here. Examples about Promises can also be seen in section 4 - Fetching Data. coreLibrary.init({ // default arguments title: 'Hello World' }).then(function () { // retrieved arguments var args = coreLibrary.args; // receiving the title through this widget arguments document.getElementById('title').innerText = args.title; });The above code simply sets the header text of the widget to be &quot;Hello World&quot; unless it was defined by the Sportsbook (through the args passed to the widget) to be something else. Adding an external DependencyWith the basic setup you only have access to the kambi-widget-core-library in the project, which can make it hard to do complex widgets using plain Javascript. If we wanted to add a library to make our jobs easier we could do so by adding a &lt;script&gt; tag in the &lt;head&gt; section of the page and using it by accessing the global values it defines, but that is not the recommended way of doing this because it can be hard to keep track of all the dependencies the project will need. As an alternative you can also add dependencies using npm. For example to add jquery to the project all we need to do is run this in the command line: npm install --save jquery and start using it by importing it in the javascript: import { coreLibrary } from 'kambi-widget-core-library'; import './index.html'; import './app.scss'; import $ from 'jquery'; coreLibrary.init({ // default arguments title: 'Hello World' }).then(function () { // retrieved arguments var args = coreLibrary.args; // receiving the title through this widget arguments $('#title').text(args.title); });In this manner it is not necessary change index.html to add javascript libraries and stylesheets. You can see a list of all available libraries in the npm registry Coding StyleThe project has linting provided by eslint. Linters enforce code-style guidelines. They can be configured to appear in your text editor (most have built-in support or a plugin to add support for eslint), but they are also verified at build time. They generate linting errors, but if they happen they do not break the build. So if desired these linting errors can be ignored. In order to keep the coding style consistent across projects the eslint rules are not customizable on a project-by-project basis. The most important part of the coding style rules is that the default indentation level is set to 3 spaces. Common Build Architecture Since all webpack build configuration of the widgets is shared and localized in the kambi-widget-build-tools dependency it is not possible to add more items to the build architecture. For example replacing SCSS with LESS is not possible. We might add some scape hatches in the future to support customizing the webpack configuration to allow modifying the build process. ES6 and JSXThe project has babel transpilation step process set up during the build so it supports the full ES6 syntax and JSX for React development in all browsers. These new syntaxes are completely optional and can be ignored completely if so desired. Important: babel only transpiles ES6 syntax, but not ES6 features like fetch API. New ES6 features need to be polyfilled in to support old browsers (for example IE11 does not support fetch API), the kambi-widget-core-library polyfills ES6 Promises so those can be safely used no matter the target browser. Besides ES6 the build process also supports JSX for React development. The only caveat is that JSX syntax is only supported in .jsx files. Since the entry point of the project is src/index.js that file needs to import another .jsx file in order to enable JSX. See more about this in section 8 - Using React and widget-components. × Search results Close "},"tutorial-3 - Production Builds and Deployment.html":{"id":"tutorial-3 - Production Builds and Deployment.html","title":"Tutorial: 3 - Production Builds and Deployment","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components 3 - Production Builds and Deployment Production Build Inside the project folder run: npm run build If the build was successful after a few seconds the widgets code will be bundled inside the /dist/ folder. All files of this folder should be deployed to whatever hosting solution you use. The sportsbook needs to point to the index.html file from this folder. Code style errors (linting) do not break the build and can be ignored if so desired. Deployment Copy the files from the /dist/ folder to whatever Content Delivery Network (CDN) you use. When configuring the sportsbook the url should point to the index.html inside this /dist/ folder in your CDN of choice. Information about configuring the widgets inside the Sportsbook can be found in the Kambi Documentation × Search results Close "},"tutorial-4 - Fetching Data.html":{"id":"tutorial-4 - Fetching Data.html","title":"Tutorial: 4 - Fetching Data","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components 4 - Fetching Data Fetching data is done through the Kambi's Offering API and the Kambi's Statistics API. The kambi-widget-core-library offers a wrapper around these API through the offeringModule and the statisticsModule. These modules take care of setting all the appropriate values in the request URLs as well as abstracting the endpoints of the APIs as functions that return Promises. Note that it is only possible to fetch data after the coreLibrary.init() call has been finished. That means inside its .then() callback. Using PromisesPromise is a way to deal with asynchronous (AJAX) requests, it allows for easier chaining and error handling of requests than callbacks. All asynchronous methods of the kambi-widget-core-library return Promises. Promises are Javascript objects and as such they have methods, these methods are then(fn) and catch(fn). Both receive a function as an argument: then(fn) fn called when the Promise is resolved, ie the request has finished successfully. Returns a new Promise catch(fn) fn called when the Promise is reject, ie the request has finished unsuccessfully. Returns a new Promise Both these functions return a new Promise object in a way that allows chaining these methods together Example import { offeringModule } from 'kambi-widget-core-library'; ... var promise = offeringModule.getEvent(someEventId); promise = promise.then(function (response) { console.log('success!'); console.log(response); }); promise = promise.catch(function (error) { // only called if an error happened console.log('error!'); console.log(error); }); // same thing as above, but in a more concise way offeringModule.getEvent(someEventId) .then(function (response) { console.log('success!'); console.log(response); }) .catch(function (error) { // only called if an error happened, for example event not found console.log('error!'); console.log(error); }); Error Handling catch(fn) also catches errors that happen inside previous then(fn) blocks. It is a good practice for Kambi Widget development to make the widget remove itself when an error happens. That means it fails gracefully and does not show in a broken state in the Sportsbook. Example import { offeringModule, widgetModule } from 'kambi-widget-core-library'; offeringModule.getLiveEvents() .then(function (response) { if (response.liveEvents.length === 0) { throw new Error('No live events!'); } console.log('success!'); console.log(response); }) .catch(function (error) { // only called if an error happened console.log('error!'); console.log(error); widgetModule.removeWidget(); // widget is removed from the Sportsbook }); Chaining Promises It is possible to chain Promises by returning a new Promise inside a then(fn) function, the subsequent then(fn) call will be invoked when this returned Promise is resolved. catch(fn) blocks in the chain will catch any errors that happen before it in the chain. import { offeringModule, widgetModule } from 'kambi-widget-core-library'; offeringModule.getLiveEvents() .then(function (response) { if (response.events.length === 0) { throw new Error('No live events!'); } // getting the first event betOffers var id = response.events[0].event.id; return offeringModule.getLiveEvent(id); // this returns a Promise }) .then(function (response) { console.log(response.betOffers); }) .catch(function (error) { // only called if an error happened in ANY request of the chain console.log('error!'); console.log(error); widgetModule.removeWidget(); // widget is removed from the Sportsbook }); Parallel Promises Sometimes we want to execute asynchronous calls in parallel for faster data-fetching, to do that we can use Promise.all(promiseArray). It returns a new Promise that is resolved when all Promises inside promiseArray resolve. Example import { offeringModule, widgetModule } from 'kambi-widget-core-library'; offeringModule.getLiveEvents() .then(function (response) { if (response.events.length === 0) { throw new Error('No live events!'); } // getting the first event betOffers var promises = []; for (var i = 0; i &lt; response.events; i++) { var id = response.events[i].event.id; var promise = offeringModule.getLiveEvent(id); promises.push(promise); } return Promise.all(promises); }) .then(function (response) { // will have all the betoffers for all live events console.log(response); }) .catch(function (error) { // only called if an error happened in ANY request of the chain console.log('error!'); console.log(error); widgetModule.removeWidget(); // widget is removed from the Sportsbook }); More about Promises Offering ModuleThe offeringModule provides data about events, their statuses and their betOffers. It also provides information about the live data for live events. Example getting all live events import { offeringModule } from 'kambi-widget-core-library'; ... offeringModule.getLiveEvents() .then(function(data) { console.log(data); }); Getting all betOffers of a single event import { offeringModule } from 'kambi-widget-core-library'; ... // if it is a pre-live event offeringModule.getEvent(eventId) .then(function(data) { console.log(data); }); // if it is a live event offeringModule.getLiveEvent(eventId) .then(function(data) { console.log(data); }); Making a filter request Filter request are a way to get all the events associated with a filter, filters are strings that define a subset of events. A few examples: football: all football events football/england: all football events from england football/england/premier_league: all football events from the english premier_league tournament football/england/premier_league/arsenal: all football events from the english premier_league in which the Arsenal team is playing football/england/premier_league/all/competitions: all events of type ET_COMPETITON from the premier_league. This excludes actual matches, returning only the overall competition data. For example &quot;Premier League Group A&quot;, &quot;Premier League Group B&quot;, &quot;Premier League&quot; (the overall tournament). football/england/premier_league/all/matches: all events of type ET_MATCH from the premier_league tournament. This excludes competitions and returns only actual matches. For example: &quot;Sunderland - Arsenal&quot;, &quot;Manchester United - Burnley&quot;. Filters also accept a wildcard called all that allows you to skip a certain part of the filter. For example football/all/all is the same as football. Examples import { offeringModule, widgetModule } from 'kambi-widget-core-library'; ... offeringModule.getEventsByFilter('football') .then(function(data) { console.log(data.events); }) offeringModule.getEventsByFilter('football/england/premier_league') .then(function(data) { console.log(data.events); }) // combining two filters offeringModule.getEventsByFilter('football/england,germany') .then(function(data) { console.log(data.events); }) Notes All offering calls that return multiple events (getEventsByFilter for example) also return its main betOffer if it exists. To get ALL betOffers of an event you need to use getEvent(eventId) or getLiveEvent(eventId) depending if the event is live or not. getEventsByFilter returns both live and pre-live matches, it is possible to differentiate between them using eventData.event.openForLiveBetting. If it is true then it the match is live and to get all its betoffers one should use getLiveEvent(eventId) instead of getEvent(eventId) See the offeringModule documentation for a list of all the methods. × Search results Close "},"tutorial-5 - Sportsbook Interaction.html":{"id":"tutorial-5 - Sportsbook Interaction.html","title":"Tutorial: 5 - Sportsbook Interaction","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components 5 - Sportsbook Interaction Interaction with the sportsbook is done through the widgetModule. A few examples of interactions are: changing the widget height, remove the widget from the Sportsbook, adding bets to the betslip. For full documentation please check the widgetModule API documentation. Note: Most of the methods inside the widgetModule only work when the widget is running inside the Sportsbook, when opening the widget as stand-alone these methods don't do anything. Widget HeightSince the widgets run inside iframes in the Sportsbook the widget needs to manually control its own height (iframes don't grow in size based in their contents height). The widgetModule provides two ways of changing the widget's height, every time the widget needs to change its height (for example when receiveing new data) one of these methods should be used widgetModule.adaptWidgetHeight() Tries to make the widget the same height as the &lt;body&gt; tag of the page, essentially making the iframe the same size of the widget. This approach doesn't always work, first the &lt;body&gt; tag can not have a 100% height styling rule, secondly this method needs to be called AFTER animations that dynamically change the &lt;body&gt; height end (both CSS animations and Javascript animations have this limitation), which basically means that animations that change the widget's height are not recommended. widgetModule.setHeight(value) Sets the height to a specific value in pixels, this method has no gotchas like the adaptWidgetHeight(), but it can be very cumbersome to keep track of the widgets height manually. Removing the WidgetThe widget can choose to remove itself from the Sportsbook, this is useful to handle unexpected states in the data (like no events to show) and to prevent the widget from being in a broken state in cases of unexpected errors: // same thing as above in a more concise manner offeringModule.getEvent(someEventId) .then(function (response) { console.log('success!'); console.log(response); }) .catch(function (error) { console.log(error); console.log('Error, maybe the event with the provided id does not exists? Widget removing itself'); widgetModule.removeWidget(); });Navigating to Other PagesThe widgetModule allows the user to redirect the user to other parts of the Sportsbook. Example: widgetModule.navigateToFilter('football/england/premier_league');Adding Bets to BetslipBetOffers returned from the offeringModule have two or more outcomes (the possible choices in the bet). The widgetModule offers a way to add those outcomes to the betslip. widgetModule.addOutcomeToBetslip(outcome.id);EventsThe widgetModule offers a publish/subscribe system to listen for a few specific events. For example widgetModule.events.subscribe('ODDS:FORMAT', function() { console.log('odds format changed!'); }); × Search results Close "},"tutorial-6 - Internationalization.html":{"id":"tutorial-6 - Internationalization.html","title":"Tutorial: 6 - Internationalization","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components 6 - Internationalization Translations are handled by the translationModule module which is part of the kambi-widget-core-library. The module fetches the corresponding translations from JSON files inside the src/i18n folder. The use of these files are optional if no internationalization is required. If the user locale is not found in this folder it will fallback to en_GB.json. These are all the currently supported locales in the Sportsbook, although they can vary by operator: cs_CZ.json, de_DE.json, es_ES.json, fr_CH.json, lt_LT.json, no_NO.json, ro_RO.json, da_DK.json, el_GR.json, et_EE.json, fr_FR.json, lv_LV.json, pl_PL.json, ru_RU.json, de_AT.json, en_AU.json, fi_FI.json, hu_HU.json, nl_BE.json, pt_BR.json, sv_SE.json, de_CH.json, en_GB.json, fr_BE.json, it_IT.json, nl_NL.json, pt_PT.json, tr_TR.json We can test translations by changing the locale parameter in modkSetupData.json { ... &quot;clientConfig&quot;: { ... &quot;locale&quot;: &quot;en_GB&quot;, ... } }Translating stringsTo translate a string we use the getTranslation() method of the translationModule import { translationModule } from 'kambi-widget-core-library'; // Translate stadium string document.getElementById('title').innerText(translationModule.getTranslation('Stadium'));On our json files we would have for example sv_SE.json { &quot;Stadium&quot;: &quot;Stadion&quot; }Translation with extra arguments We can also provide arguments when translating. In our json files we can define the number of arguments, so for example: en_GB.json: { &quot;WelcomeTo&quot;: &quot;Welcome {0} to {1}&quot; } sv_SE.json: { &quot;WelcomeTo&quot;: &quot;Välkomna {0} till {1}&quot; } And the translation would be called like so: import { translationModule } from 'kambi-widget-core-library'; var user = 'Jim', place = 'Sportsbook'; // Translate welcome message $('#welcome').text(translationModule.getTranslation('WelcomeTo', user, place));That would result to Welcome Jim to Sportsbook for 'en_GB' locale and Välkomna Jim till Sportsbook for 'sv_SE' × Search results Close "},"tutorial-7 - Styling.html":{"id":"tutorial-7 - Styling.html","title":"Tutorial: 7 - Styling","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components 7 - Styling Styling should preferably be done by using Kambi classes where ever thats possible to keep the style consistent with the rest of the client. Kambi client will load widgets.css which will have most of the classes needed to style a widget, matching the operator theme. Note: Kambi uses BEM methodology Basic CSS classes .KambiWidget-font Default font that should be used. .KambiWidget-primary-color Default color for emphasized text .KambiWidget-primary-background-color Default background color for emphasis. .KambiWidget-primary-text-color Default color for emphasized text inside emphasized background .KambiWidget-card-background-color Default backrgound color for cards .KambiWidget-card-background-color--hoverable:hover .KambiWidget-card-background-color--clickable:active .KambiWidget-card-text-color Default font color for text inside cards .KambiWidget-card-support-text-color Alternative (secondary) font color for text inside cards .KambiWidget-header Default styling (background color, text color and font) used for headers Please note that coreLibrary will add .KambiWidget-card-text-color, .KambiWidget-card-background-color, .KambiWidget-font to the &lt;HTML&gt; tag Here is a screenshot showing various classes in use: × Search results Close "},"tutorial-8 - Using React and widget-components.html":{"id":"tutorial-8 - Using React and widget-components.html","title":"Tutorial: 8 - Using React and widget-components","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials 1 - Introduction2 - Development3 - Production Builds and Deployment4 - Fetching Data5 - Sportsbook Interaction6 - Internationalization7 - Styling8 - Using React and widget-components 8 - Using React and widget-components Widget-components is a collection of reusable components written with React framework. The use of React and these widget-components is completely optional, but they help a lot in the development and with keeping the style of the widget consistent with the style of the Sportsbook. Currently the list involves following components: OutcomeButton Pre-requisitesYou can start using widget-components by installing it as a dependency to the project by running: npm install kambi-widget-components JSX syntax works only in .jsx files, so index.js should import a .jsx file like this: import { ComponentName } from 'kambi-widget-components'; import React from 'react'; import ReactDOM from 'react-dom'; ... ReactDOM.render( &lt;ComponentName componentProp1=&quot;someValue&quot; componentProp2={coreLibrary.args.someArgument} /&gt;, document.getElementById('root') );ReactDOM.render should only be called after coreLibrary.init() is resolved. kambi-widget-components also includes react and react-dom dependencies and as such they don't need to be installed in the project. You can also make your own components and have the whole widget be a React component if desired. OutcomeButtonFor example OutcomeButton accepts the following props: outcome (required): a outcome object from the offeringModule event: a event object from the offeringModule withLabel: a Boolean that defines if a label should be shown in the button or not customLabel: overrides the default label with this value Example: render() { return ( &lt;OutcomeButton outcome={ this.props.outcome } &gt;&lt;/OutcomeButton&gt; ); }useRealReact flagBy default the project uses react-lite in production build which is a light-weight version of react with focus on small file-size instead of the normal react. While in development mode though (npm run start) the project uses the real react because it provides more debug functionalities. This is handled by the kambi-widget-build-tools automatically. React Lite is an alternative implementation of React and as such it can have incompatibilities, although so far we haven't encountered any. If you want to override the default behavior of the build you can force the use of a specific React version by placing a useRealReact object in package.json. You can define different values for development and production environment. package.json: { ... &quot;useRealReact&quot;: { &quot;development&quot;: [Boolean], &quot;production&quot;: [Boolean] } }By default development is true and production is false × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
