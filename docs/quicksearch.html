<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"coreLibrary.js.html":{"id":"coreLibrary.js.html","title":"Source: coreLibrary.js","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials Building and Deploying Widgets Source: coreLibrary.js import offeringModule from './Module/offeringModule'; import statisticsModule from './Module/statisticsModule'; import translationModule from './Module/translationModule'; import utilModule from './Module/utilModule'; import widgetModule from './Module/widgetModule'; /** * Main module that holds the other modules as well as widget * related configurations * @module coreLibrary */ function checkStatus(response) { if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) { return response; } else { var error = new Error(response.statusText); error.response = response; throw error; } } function checkBrowser() { var ua = window.navigator.userAgent; var getFirstMatch = function (regex) { var match = ua.match(regex); return (match &amp;&amp; match.length &gt; 1 &amp;&amp; match[1]) || ''; }; var versionIdentifier = getFirstMatch(/version\\/(\\d+(\\.\\d+)?)/i); if (/android/i.test(ua)) { return { browser: 'android', browserVersion: versionIdentifier }; } else if (/(ipod|iphone|ipad)/i.test(ua)) { return { browser: 'ios', browserVersion: getFirstMatch(/(?:mxios)[\\s\\/](\\d+(?:\\.\\d+)+)/i) }; } else if (/msie|trident/i.test(ua)) { return { browser: 'internet-explorer', browserVersion: getFirstMatch(/(?:msie |rv:)(\\d+(\\.\\d+)?)/i) }; } else if (/chrome|crios|crmo/i.test(ua)) { return { browser: 'chrome', browserVersion: getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.\\d+)?)/i) }; } else if (/safari|applewebkit/i.test(ua)) { return { browser: 'safari', browserVersion: versionIdentifier }; } else if (/chrome.+? edge/i.test(ua)) { return { browser: 'microsoft-edge', browserVersion: getFirstMatch(/edge\\/(\\d+(\\.\\d+)?)/i) }; } else if (/firefox|iceweasel|fxios/i.test(ua)) { return { browser: 'firefox', browserVersion: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \\/](\\d+(\\.\\d+)?)/i) }; } } /* * Downloads a resource from given URL. * @param {string} url URL of resource * @returns {Promise.&lt;{status: number, statusText: string, body: string}&gt;} */ function download(url) { return new Promise((resolve, reject) =&gt; { // fetch API is not supported in IE11 so we use // old-school XMLHttpRequest const xhr = new XMLHttpRequest(); xhr.open('GET', url, true); xhr.onload = function() { const response = { status: xhr.status, statusText: xhr.statusText, body: 'response' in xhr ? xhr.response : xhr.responseText, }; resolve(response); }; xhr.onerror = () =&gt; reject(new TypeError('Network request failed')); xhr.ontimeout = () =&gt; reject(new TypeError('Network request failed')); xhr.send(); }); } export default { /** * Name of the browser that is running the widget * @type {String} */ browser: checkBrowser().browser, /** * Browser version * @type {String} */ browserVersion: checkBrowser().browserVersion, /** * Kambi Widget API version to use * @type {String} * @private */ expectedApiVersion: '1.0.0.15', /** * Config object. This data comes from the sportsbook and should not be manually changed. When in running the widget stand alone this values are retrieved from ./src/mockSetupData.json * @name config * @type {Object} * @property {String} apiBaseUrl url of the offering api to use * @property {Boolean} auth * @property {Number} channelId * @property {String} currency what currency to use * @property {String} customer the customer to use with the offering API * @property {String} device what kind of device does the user have. Possible values: 'desktop', 'mobile' * @property {String} locale locale of the user, example: 'en_GB', 'sv_SE' * @property {String} market market to use with the offering API. * @property {String} oddsFormat the odds format to show. Possible values: 'decimal', 'fractional', 'american'. To listen to changes to this value use widgetModule.events.subscribe('ODDS:FORMAT', eventHandlerFn); * @property {String} offering the offering to use with the offering API * @property {String} routeRoot * @property {Boolean} streamingAllowedForPlayer * @property {Number} client_id * @property {String} version */ _config: { apiBaseUrl: '', auth: false, channelId: 1, currency: 'EUR', customer: '', device: 'desktop', locale: 'en_GB', market: 'GB', oddsFormat: 'decimal', offering: '', routeRoot: '', streamingAllowedForPlayer: true, client_id: 2, version: 'v2' }, get config () { return this._config; // eslint-disable-line no-underscore-dangle }, set config (config) { /* eslint-disable no-underscore-dangle */ for (var i in config) { if (config.hasOwnProperty(i) &amp;&amp; this._config.hasOwnProperty(i)) { this._config[i] = config[i]; } } // Make sure that the routeRoot is not null or undefined if (this._config.routeRoot == null) { this._config.routeRoot = ''; } else if (this._config.routeRoot.length &gt; 0 &amp;&amp; this._config.routeRoot.slice(-1) !== '/') { // If the routeRoot is not empty we need to make sure it has a trailing slash this._config.routeRoot += '/'; } /* eslint-enable no-underscore-dangle */ }, /** * Sets odds format. Calling this method changes config.oddsFormat * @memberOf module:coreLibrary * @param {String} oddsFormat * @private */ setOddsFormat (oddsFormat) { this._config.oddsFormat = oddsFormat; // eslint-disable-line no-underscore-dangle }, /** * default args object * @private */ _defaultArgs: {}, get defaultArgs () { return this._defaultArgs; // eslint-disable-line no-underscore-dangle }, set defaultArgs (defaultArgs) { this._defaultArgs = defaultArgs; // eslint-disable-line no-underscore-dangle }, /** * args object for the widget, merges the default args provided by coreLibrary.init() with the ones that come from the sportsbook. There are some pre-defined arguments that all widgets accept, but most of them are widget-defined. * @property {String} customCssUrl URL to a CSS file to add to the page, expressions like &quot;{customer}&quot; are replaced with their values in coreLibrary.config. This is useful to load different stylesheets based on operator name. Example: Say coreLibrary.config.customer is 'kambi', then if this argument was set: { customCssUrl: &quot;https://someurl.com/customcss/{customer}/style.css&quot; } It would load this CSS file and add it to the page: https://someurl.com/customcss/kambi/style.css * @property {String} customCssUrlFallback fallback if the fetching of customCssUrl fails * @property {Array&lt;Object&gt;} conditionalArgs Optional, specify arguments to be applied based on some condition based in the values inside coreLibrary.config or coreLibrary.pageInfo example: conditionalArgs: [ // if coreLibrary.config.currency is 'EUR' apply { euro: true, dollars: false } to the arguments { config: { currency: 'EUR' }, args: { euro: true, dollars: false } }, // if market is 'IT' AND offering is 'IT' apply { italian: true } to the arguments { config: { market: 'IT', offering: 'IT' }, args: { italian: true } }, ] * @name args */ _args: null, get args () { return this._args; // eslint-disable-line no-underscore-dangle }, set args (args) { /* eslint-disable no-underscore-dangle */ if (this._args != null) { throw Error('Do not override coreLibrary.args'); } args = Object.assign({}, this.defaultArgs, args); // Handling conditionalArgs if (args.conditionalArgs != null) { args.conditionalArgs.forEach((carg) =&gt; { var apply = true; if (carg.clientConfig != null) { Object.keys(carg.clientConfig).forEach((key) =&gt; { if (this.config[key] !== carg.clientConfig[key]) { apply = false; } }); } if (carg.pageInfo != null) { Object.keys(carg.pageInfo).forEach((key) =&gt; { if (this.pageInfo[key] !== carg.pageInfo[key]) { apply = false; } }); } if (apply) { console.log('Applying conditional arguments:'); console.log(carg.args); args = Object.assign(args, carg.args); } }); } this._args = args /* eslint-enable no-underscore-dangle */ }, /** * Information about the page that the widget is being loaded from * @name pageInfo * @type {Object} * @property {Array(String)} leaguePaths array with league paths. Example:['football/england/premier_league'] * @property {String} pageParam parameter for this page. For a page of type 'filter' an example would be 'football/england/premier_league' * @property {String} pageTrackingPath the path in the url for this page. For example: '/filter/football/england/premier_league' * @property {String} pageType type of the page, examples: 'home', 'filter' */ _pageInfo: { leaguePaths: [], pageParam: '', pageTrackingPath: '', pageType: '' }, get pageInfo () { return this._pageInfo; // eslint-disable-line no-underscore-dangle }, set pageInfo (pageInfo) { /* eslint-disable no-underscore-dangle */ // Check if the last character in the pageParam property is a slash, if not add it so we can use this property in filter requests if (pageInfo.pageType === 'filter' &amp;&amp; pageInfo.pageParam.substr(-1) !== '/') { pageInfo.pageParam += '/'; } this._pageInfo = pageInfo; /* eslint-enable no-underscore-dangle */ }, /** * Versions of the API provided by the sportsbook * @name apiVersions * @type {Object} * @property {String} client * @property {String} libs * @property {String} wapi */ _apiVersions: { client: '', libs: '', wapi: '' }, get apiVersions () { return this._apiVersions; // eslint-disable-line no-underscore-dangle }, set apiVersions (versions) { /* eslint-disable no-underscore-dangle */ for (var i in versions) { if (versions.hasOwnProperty(i) &amp;&amp; this._apiVersions.hasOwnProperty(i)) { this._apiVersions[i] = versions[i]; } } /* eslint-enable no-underscore-dangle */ }, /** * The name sent to Kambi API for analytics data collection * @private */ widgetTrackingName: null, /** * Promise that is resolved when all the CSS has finished loading * @type Promise */ cssLoadedPromise: null, /** * Initializes the Kambi api * Uses ./src/mockSetupData.json as coreLibrary.configs if not loaded inside the sportsbook (ie opened the widget directly). * @param {Object} defaultArgs arguments to be used if they are not provided by the sportsbook * @returns {Promise} resolved when everything is ready. If an error happens during fetching the error can be catched in a .catch() function */ init (defaultArgs) { this.defaultArgs = defaultArgs; return new Promise((resolve, reject) =&gt; { // injecting widget-api in the page return this.getFile('https://c3-static.kambi.com/sb-mobileclient/widget-api/' + this.expectedApiVersion + '/kambi-widget-api.js') .then((content) =&gt; { const tag = document.createElement('script'); tag.setAttribute('id', 'widget-api'); tag.textContent = content; const head = document.getElementsByTagName('head')[0]; // custom CSS should be the LAST CSS in the page head.insertBefore(tag, head.lastChild); return 'success'; }).catch((err) =&gt; { console.error('Error loading widget api') console.error(err); reject(); }) .then(() =&gt; { // applies the setup data and sets up the CSS and translations var applySetupData = (setupData) =&gt; { this.config = setupData.clientConfig; this.pageInfo = setupData.pageInfo; this.apiVersions = setupData.versions; this.args = setupData.arguments; const translationPromise = translationModule.fetchTranslations(setupData.clientConfig.locale); const operatorCssPromise = this.injectOperatorCss( this.apiVersions.wapi, this.config.customer, this.config.offering); const customCssPromise = this.injectCustomCss( this.args.customCssUrl, this.args.customCssUrlFallback); // most widgets don't need to wait for the CSS to be loaded // so we keep a promise instead of waiting for it this.cssLoadedPromise = Promise.all([operatorCssPromise, customCssPromise]); translationPromise .then(() =&gt; { resolve(); }) .catch((err) =&gt; { reject(); }); }; if (window.KambiWidget) { // For development purposes we might want to load a widget on it's own so we check if we are in an iframe, if not then load some fake data if (window.self === window.top) { console.warn(window.location.host + window.location.pathname + ' is being loaded as stand-alone'); // Load the mock config data this.getData('mockSetupData.json') .then((mockSetupData) =&gt; { // Output some debug info that could be helpful console.debug('Loaded mock setup data'); console.debug(mockSetupData); // Apply the mock config data to the core applySetupData(mockSetupData); }) .catch((error) =&gt; { console.debug('Failed to fetch mockSetupData'); console.trace(error); reject(); }); } else { window.KambiWidget.apiReady = (api) =&gt; { widgetModule.api = api; // Request the setup info from the widget api widgetModule.requestSetup((setupData) =&gt; { // Request the outcomes from the betslip so we can update our widget, also sets up a subscription for future betslip updates widgetModule.requestBetslipOutcomes(); // Request the odds format that is set in the sportsbook, this also sets up a subscription for future odds format changes widgetModule.requestOddsFormat(); // Apply the config data to the core applySetupData(setupData); }); }; // Setup the response handler for the widget api window.KambiWidget.receiveResponse = (dataObject) =&gt; { widgetModule.handleResponse(dataObject); }; } } else { console.warn('Kambi widget API not loaded'); reject(); } }); }); }, /** * Dynamically creates a style tag and returns it * @param id {String} the id to add to the tag * @param content {String} text content of the tag (the styles) * @returns HTMLElement the tag created * @private */ createStyleTag (id, url) { const tag = document.createElement('link'); tag.setAttribute('id', id); tag.setAttribute('rel', 'stylesheet'); tag.setAttribute('type', 'text/css'); tag.setAttribute('href', url); return tag; }, /** * Injects operator specific CSS based on widget API version, * customer and offering * @param wApiVersion {String|Null} If null will use expectedApiVersion * @param customer {String} * @param offering {String} * @returns {Promise} When resolved the stylesheet has been successfully added to the page * @private */ injectOperatorCss (wApiVersion, customer, offering) { if ( wApiVersion == null || wApiVersion === '') { wApiVersion = this.expectedApiVersion; } const url = '//c3-static.kambi.com/sb-mobileclient/widget-api/' + wApiVersion + '/resources/css/' + customer + '/' + offering + '/widgets.css'; return this.getFile(url) .then((content) =&gt; { const tag = this.createStyleTag('operator-css', url); const head = document.getElementsByTagName('head')[0]; // opereator CSS should be the FIRST CSS in the page head.insertBefore(tag, head.firstChild); }) .catch((err) =&gt; { console.warn('Could not inject Operator CSS'); }); }, /** * Injects stylesheet based on configuration parameters (coreLibrary.config) * Replaces expressions like &quot;{customer}&quot; in the strings provided * @param customCssUrl {String} * @param customCssUrlFallback {String} Fallback if the first URL fetch fails * @returns {Promise} when resolved the stylesheet has been successfully added to the page * @private */ injectCustomCss (customCssUrl, customCssUrlFallback) { if (customCssUrl == null) { return Promise.resolve(''); } if (customCssUrlFallback == null) { customCssUrlFallback = ''; } customCssUrl = utilModule.replaceConfigParameters(customCssUrl); customCssUrlFallback = utilModule.replaceConfigParameters(customCssUrlFallback); const appendToHead = (url) =&gt; { const tag = this.createStyleTag('custom-css', url); const head = document.getElementsByTagName('head')[0]; // custom CSS should be the LAST CSS in the page head.insertBefore(tag, null); }; return this.getFile(customCssUrl) .then(( response ) =&gt; { appendToHead(customCssUrl); return response; }).catch(( error ) =&gt; { if (customCssUrlFallback !== '') { console.debug('Error fetching custom css, trying fallback'); return this.getFile(customCssUrlFallback) .then(( response ) =&gt; { appendToHead(customCssUrlFallback); return response; }).catch(( error ) =&gt; { console.debug('Error fetching custom css fallback'); return error; }); } else { console.debug('Error fetching custom css, no fallback present'); return error; } }); }, /** * Makes a ajax request and parses its response as JSON * @param {String} url * @returns {Promise} resolved when the data fetching finishes. If an error happens during fetching the error can be catched in a .catch() function */ getData (url) { return download(url) .then(checkStatus) .then((response) =&gt; { return JSON.parse(response.body) }) .catch((error) =&gt; { console.debug('Error fetching data'); console.trace(error); throw error; }); }, /** * Makes an ajax request and returns the response body as text * @param {String} url * @returns {Promise} resolved when the data fetching finishes. If an error happens during fetching the error can be catched in a .catch() function */ getFile (url) { return download(url) .then(checkStatus) .then(response =&gt; response.body) .catch((error) =&gt; { console.debug('Error fetching file'); console.trace(error); throw error; }); }, /** * Sets widget tracking name for analytics purposes. This tracking name is used for calls to add bets to the betslip * @param {String} name The name to use */ setWidgetTrackingName (name) { this.widgetTrackingName = name; } }; × Search results Close Documentation generated by JSDoc 3.4.2 on Thu Oct 20th 2016 using the DocStrap template. "},"Module_offeringModule.js.html":{"id":"Module_offeringModule.js.html","title":"Source: Module/offeringModule.js","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials Building and Deploying Widgets Source: Module/offeringModule.js import coreLibrary from '../coreLibrary'; /** * Module with methods to request data from the offering API * The offering API has information concerning events (matches, competations) and their respective betoffers as well as live data if available * All methods in this module return Promises that are resolved when the data is ready and throws errors (that can be handled with .catch()) on failure * @module offeringModule */ export default { /** * Get group events * @param {number|string} groupId Group id * @returns {Promise} */ getGroupEvents (groupId) { var requesPath = '/event/group/' + groupId + '.json'; return this.doRequest(requesPath); }, /** * Get group information. * @param {Number|String} groupId Group id * @returns {Promise} */ getGroup (groupId) { var requesPath = '/group/' + groupId + '.json'; return this.doRequest(requesPath); }, /** * Get events by filter * @param {String} filter Filter string, eg: football * @param {Object} params Request relevant parameters * @returns {Promise} */ getEventsByFilter (filter, params) { // Todo: Update this method once documentation is available var requestPath = '/listView/' + filter; return this.doRequest(requestPath, params, 'v3'); }, /** * Normalizes v2 api betoffers * @param {Object} betOffer Betoffer object we get from api * @private */ adaptV2BetOffer (betOffer) { if (betOffer.suspended === true) { betOffer.open = false; } }, /** * Normalizes the v2 api response * @param {Object} liveData Livedata object we get from api * @private */ adaptV2LiveData (liveData) { if (liveData != null &amp;&amp; liveData.statistics != null) { var statistics = liveData.statistics; if (statistics.sets != null) { statistics.setBasedStats = statistics.sets; delete statistics.sets; } if (statistics.football != null) { statistics.footballStats = statistics.football; delete statistics.football; } } }, /** * Normalizes the v2 event object * @private */ adaptV2Event (event) { // v3 and v2 event objects are almost the same // only a few attributes we don't use are different }, /** * Get live event data only, eg: match statistics, score, macthClock * @param {Number|String} eventId The event id we need to fetch * @returns {Promise} * @private */ getLiveEventData (eventId) { var requestPath = '/event/' + eventId + '/livedata.json'; return this.doRequest(requestPath, null, null, true) .then((res) =&gt; { this.adaptV2LiveData(res); return res; }); }, /** * Get all live events * @returns {Promise} * @private */ getLiveEvents () { var requestPath = '/event/live/open.json'; return this.doRequest(requestPath, null, null, true) .then((res) =&gt; { if (res.error != null) { return res; } var events = res.liveEvents; res.events = events; res.events.forEach(this.adaptV2Event); delete res.liveEvents; delete res.group; events.forEach((e) =&gt; { e.betOffers = []; if (e.mainBetOffer != null) { this.adaptV2BetOffer(e.mainBetOffer); e.betOffers.push(e.mainBetOffer); delete e.mainBetOffer; } this.adaptV2LiveData(e.liveData); }); return res; }); }, /** * Returns a live event * @param {Number|String} eventId The event id we need to fetch * @returns {Promise} */ getLiveEvent (eventId) { var requestPath = '/betoffer/live/event/' + eventId + '.json'; return this.doRequest(requestPath, null, null, true) .then((res) =&gt; { res.betOffers = res.betoffers; delete res.betoffers; res.betOffers.forEach(this.adaptV2BetOffer); res.event = res.events[0]; this.adaptV2Event(res.event); delete res.events; return res; }); }, /** * Get live events by filter * @param {String} filter Filter string * @returns {Promise} */ getLiveEventsByFilter (filter) { // Todo: implement a filter request when the offering API supports it filter = filter.replace(/\\/$/, ''); var filterTerms = filter.split('/'); filterTerms = filterTerms.slice(0, 3); var requestPath = '/listView/all/all/all/all/in-play/'; return new Promise((resolve, reject) =&gt; { this.doRequest(requestPath, null, 'v3') .then((response) =&gt; { var result = { events: [] }, i = 0, len = response.events.length; for (; i &lt; len; ++i) { var j = 0, termLen = response.events[i].event.path.length, addEvent = true; if (termLen &gt; filterTerms.length) { termLen = filterTerms.length; } for (; j &lt; termLen; ++j) { if (filterTerms[j] !== 'all' &amp;&amp; response.events[i].event.path[j].termKey !== filterTerms[j]) { addEvent = false; } } if (addEvent) { result.events.push(response.events[i]); } } resolve(result); }); }); }, /** * Requests and event from api * @param {String} eventId The event id we need to fetch * @returns {Promise} */ getEvent (eventId) { return this.doRequest('/betoffer/event/' + eventId + '.json') .then((res) =&gt; { res.betOffers = res.betoffers; delete res.betoffers; res.betOffers.forEach(this.adaptV2BetOffer); res.event = res.events[0]; this.adaptV2Event(res.event); delete res.events; return res; }); }, /** * Request the highlight resource which is what is shown under the &quot;Popular&quot; section in the Sportsbook * @returns {Promise} */ getHighlight () { return this.doRequest('/group/highlight.json') .then((highlights) =&gt; { // sorting based on sortOrder if ( Array.isArray(highlights.groups) ) { highlights.groups.sort(( a, b ) =&gt; { if ( parseInt(a.sortOrder, 10) &gt; parseInt(b.sortOrder, 10) ) { return 1; } if ( parseInt(a.sortOrder, 10) &lt; parseInt(b.sortOrder, 10) ) { return -1; } return 0; }); } return highlights; }); }, /** * Makes a request to provided path setting the appropriated URL parameters. Usually this method should not be called directly, unless you want to access an endpoint that is not available in the other methods The final url looks like: coreLibrary.config.apiBaseUrl + version + coreLibrary.config.offering + requestPath Example (same as calling offeringModule.getLiveEvents() but forcing to use Portugal Portuguese locale) doRequest('/event/live/open.json' { lang: 'pt_PT' }); this call would fetch this url: https://api.kambi.com/offering/api/v2/kambi/event/live/open.json?lang=pt_PT&amp;market=kambi&amp;client_id=2&amp;include=&amp;betOffers=COMBINED&amp;categoryGroup=COMBINED&amp;displayDefault=true&amp;nocache=1476973932524 * @param {string} requestPath the path to the request * @param {object} params params to use, can override the parameters this method usually sets * @param {number|string} version which version of the API to use. Some endpoints are 'v2' and some are 'v3' * @param {boolean} noCache if true will add a cache-busting URL parameter. Defaults to true * @returns {Promise} */ doRequest (requestPath, params, version, noCache) { var config = coreLibrary.config; if (config.offering == null) { console.warn('The offering has not been set, is the right widget api version loaded?'); } else { var apiUrl = config.apiBaseUrl.replace('{apiVersion}', (version != null ? version : config.version)); var requestUrl = apiUrl + config.offering + requestPath; var overrideParams = params || {}; var requestParams = { lang: overrideParams.locale || config.locale, market: overrideParams.market || config.market, client_id: overrideParams.client_id || config.client_id, include: overrideParams.include || '', betOffers: overrideParams.betOffers || 'COMBINED', categoryGroup: overrideParams.categoryGroup || 'COMBINED', displayDefault: overrideParams.displayDefault || true }; if (noCache === true) { requestParams.nocache = Date.now(); } requestUrl += '?' + Object.keys(requestParams).map(function (k) { return encodeURIComponent(k) + '=' + encodeURIComponent(requestParams[k]); }).join('&amp;'); return coreLibrary.getData(requestUrl); } } }; × Search results Close Documentation generated by JSDoc 3.4.2 on Thu Oct 20th 2016 using the DocStrap template. "},"Module_statisticsModule.js.html":{"id":"Module_statisticsModule.js.html","title":"Source: Module/statisticsModule.js","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials Building and Deploying Widgets Source: Module/statisticsModule.js import coreLibrary from '../coreLibrary'; /** * Module to access statistics API * The statistics API has information concerning historical data of events (matches, competitions) * All methods in this module return Promises that are resolved when the data is ready and throws errors (that can be handled with .catch()) on failure * @module statisticsModule */ export default { /** * Configuration * @type {Object} * @property {String} baseApiUrl the baseURL for statistics API requests */ config: { baseApiUrl: 'https://api.kambi.com/statistics/api/' }, /** * Requests league table statistics data from api. * @param {String} filter a filter string to a competition. Example 'football/england/premier_league' * @returns {Promise} */ getLeagueTableStatistics (filter) { // Remove url parameters from filter filter = filter.match(/[^?]*/)[0]; // Removing trailing and starting slashes if present if ( filter[filter.length - 1] === '/' ) { filter = filter.slice(0, -1); } if ( filter[0] === '/' ) { filter = filter.slice(1); } return coreLibrary.getData(this.config.baseApiUrl + coreLibrary.config.offering + '/leaguetable/' + filter + '.json'); }, /** * Requests H2H statistics data from api. * @param {String|Number} eventId id of a match * @returns {Promise} */ getHeadToHeadStatistics (eventId) { return coreLibrary.getData(this.config.baseApiUrl + coreLibrary.config.offering + '/h2h/event/' + eventId + '.json'); }, /** * Requests TPI statistics data from api. * @param {String|Number} eventId id of a match * @returns {Promise} */ getTeamPerformanceStatistics (eventId) { return coreLibrary.getData(this.config.baseApiUrl + coreLibrary.config.offering + '/tpi/event/' + eventId + '.json'); } }; × Search results Close Documentation generated by JSDoc 3.4.2 on Thu Oct 20th 2016 using the DocStrap template. "},"Module_translationModule.js.html":{"id":"Module_translationModule.js.html","title":"Source: Module/translationModule.js","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials Building and Deploying Widgets Source: Module/translationModule.js import coreLibrary from '../coreLibrary'; /** * Module with internationalization methods * Provides a very simple internationalization mechanism * that is not relient in any library. * The loading of the right internationalization JSON file is handled automatically * @module translationModule */ export default { /** * fetched from the i18n folder JSON files. Only the current * locale strings are fetched * @type {Object} */ i18nStrings: {}, /** * Makes a request to fetch the provided locale strings * @param {String} locale Locale string, eg: sv_SE * @returns {Promise} * @private */ fetchTranslations (locale) { if (locale == null) { locale = 'en_GB'; } var self = this; var path = 'i18n/'; return new Promise((resolve, reject) =&gt; { coreLibrary.getData(path + locale + '.json') .then((response) =&gt; { this.i18nStrings = response; resolve(); }) .catch((error) =&gt; { if (locale !== 'en_GB') { console.debug('Could not load translations for ' + locale + ' falling back to en_GB'); self.fetchTranslations('en_GB').then(resolve); } else { console.debug('Could not load translations for en_GB'); console.trace(error); resolve(); } }); }); }, /** * Returns translated string based of a provided key. * @param {String} key Key to fetch translation for * @param {...String} args arguments to replace inside the translated string * @example * en_GB.json: * { &quot;welcomeUserToPlace&quot;: &quot;Welcome {0} to {1}&quot; } * Javascript: * getTranslation('welcomeUserToPlace', 'Daniel', 'Stadium') =&gt; 'Welcome Daniel to Stadium' * @returns {String} the localized string */ getTranslation: function (key, ...args) { if (this.i18nStrings[key] != null) { var str = this.i18nStrings[key]; for (var i = 0; i &lt; args.length; i++) { var replacement = args[i] || ''; str = str.replace('{' + i + '}', replacement); } return str; } return key; } }; × Search results Close Documentation generated by JSDoc 3.4.2 on Thu Oct 20th 2016 using the DocStrap template. "},"Module_utilModule.js.html":{"id":"Module_utilModule.js.html","title":"Source: Module/utilModule.js","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials Building and Deploying Widgets Source: Module/utilModule.js import translationModule from './translationModule'; import coreLibrary from '../coreLibrary'; /** * Module with utility functions * @module utilModule */ export default { /** * Util method for return unique items between arrays * @param {Array} A First array * @param {Array} B Second array * @returns {Array} * @private */ diffArray (A, B) { var map = {}, C = []; for (var i = B.length; i--;) { map[B[i]] = null; } // any other value would do for (var i = A.length; i--;) { if (!map.hasOwnProperty(A[i])) { C.push(A[i]); } } return C; }, /* Replaces expressions like &quot;{customer}&quot; from the provided string * to the value the have in the coreLibrary.config object * @param {String} str the string to replace the expressions in */ replaceConfigParameters (str) { if (str == null) { return str; } const config = coreLibrary.config; Object.keys(config).forEach((key) =&gt; { var regex = new RegExp('{' + key + '}', 'g'); var value = config[key]; str = str.replace(regex, value); }); return str; }, /** * Get decimal formatted odds. * @param {Number} odds Odds number * @returns {Number} */ getOddsDecimalValue (odds) { if (odds &lt; 100) { return odds.toFixed(2); } else if (odds &lt; 1000) { return odds.toFixed(1); } else { return odds.toFixed(0); } }, /** * Returns the outcome label translated. * @param {Object} outcome A betoffer outcome object * @param {Object} event Event object * @returns {string} */ getOutcomeLabel (outcome, event) { switch (outcome.type) { case 'OT_ONE': // Outcome has label 1. Applies to Threeway bet offers. return event.homeLabelCustom &amp;&amp; event.homeLabelCustom !== '' ? event.homeLabelCustom : event.homeName; case 'OT_CROSS': // Outcome has label X. Applies to Threeway bet offers. return translationModule.getTranslation('draw'); case 'OT_TWO': // Outcome has label 2. Applies to Threeway bet offers. return event.awayLabelCustom &amp;&amp; event.awayLabelCustom !== '' ? event.awayLabelCustom : event.awayName; case 'OT_OVER': // The “Over” outcome in Over/Under bet offer. return outcome.label + ' ' + (outcome.line / 1000); case 'OT_UNDER': // The “Under” outcome in Over/Under bet offer. return outcome.label + ' ' + (outcome.line / 1000); // Todo: Impelement these responses with translations // case 'OT_ODD': //The “Odd” outcome in Odd/Even bet offer. // break; // case 'OT_EVEN': //The “Even” outcome in Odd/Even bet offer. // break; // case 'OT_ONE_ONE': //1-1 outcome in Halftime/fulltime bet offer. // break; // case 'OT_ONE_TWO': //1-2 outcome in Halftime/fulltime bet offer. // break; // case 'OT_ONE_CROSS': //1-X outcome in Halftime/fulltime bet offer. // break; // case 'OT_TWO_ONE': //2-1 outcome in Halftime/fulltime bet offer. // break; // case 'OT_TWO_TWO': //2-2 outcome in Halftime/fulltime bet offer. // break; // case 'OT_TWO_CROSS': //2-X outcome in Halftime/fulltime bet offer. // break; // case 'OT_CROSS_ONE': //X-1 outcome in Halftime/fulltime bet offer. // break; // case 'OT_CROSS_TWO': //X-2 outcome in Halftime/fulltime bet offer. // break; // case 'OT_CROSS_CROSS': //X-X outcome in Halftime/fulltime bet offer. // break; // case 'OT_ONE_OR_TWO': //1 or 2 outcome in Double Chance bet offer. // break; // case 'OT_ONE_OR_CROSS': //1 or X outcome in Double Chance bet offer. // break; // case 'OT_CROSS_OR_TWO': //X or 2 outcome in Double Chance bet offer. // break; // case 'OT_YES': //“Yes” outcome in Head To Head and Yes/No bet offer. // break; // case 'OT_NO': //“No” outcome in Head To Head and Yes/No bet offer. // break; // case 'OT_OTHER': //“Other results” outcome in Result bet offer. // break; // case 'OT_UNTYPED': //Outcome does not have type. // break; // case 'OT_WC_HOME': //Outcome has label Home Win. Applies to WinCast bet offers. // break; // case 'OT_WC_DRAW': //Outcome has label Draw. Applies to WinCast bet offers. // break; // case 'OT_WC_AWAY': //Outcome has label Away Win. Applies to WinCast bet offers. // break; default: console.warn('Unhandled outcome type: ' + outcome.type, outcome); return outcome.label; } } }; × Search results Close Documentation generated by JSDoc 3.4.2 on Thu Oct 20th 2016 using the DocStrap template. "},"Module_widgetModule.js.html":{"id":"Module_widgetModule.js.html","title":"Source: Module/widgetModule.js","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials Building and Deploying Widgets Source: Module/widgetModule.js /** * Module with methods to manipulate the widget and interact with the sportsbook * @module widgetModule */ import utilModule from './utilModule'; import coreLibrary from '../coreLibrary'; export default { /** * Widget API object * @type {object} * @private */ api: { // placeholders for when running outside of the sportsbook requestSetup () { }, request () { }, set () { }, remove () { }, createUrl () { }, createFilterUrl (terms, urlBase) { urlBase = urlBase || 'filter'; var segments = terms.filter(term =&gt; term.indexOf('/') === 0) .reduce((segments, term) =&gt; { var coords = []; term.replace(/\\/+$/, '').split('/').slice(1).forEach((termKey, i) =&gt; { if (!(i in segments)) { segments[i] = []; } var pointer = segments[i]; if (i &gt; 0) { coords.forEach((coord) =&gt; { for (var j = 0; j &lt;= coord; j++) { if (pointer[j] == null) { pointer.push(j === coord ? [] : 'all'); } } pointer = pointer[coord]; }); } if (pointer.indexOf(termKey) === -1) { pointer.push(termKey); } coords[i] = pointer.length - 1; return coords[i]; }); return segments; }, []); var route = '#' + urlBase.replace(/.*?#/, '').replace(/^\\//, ''); route += segments.reduce((str, segment) =&gt; str + '/' + JSON.stringify(segment).slice(1, -1), '') .replace(/&quot;/g, '') .replace(/(,all)+(\\/|\\]|$)/g, '$2'); for (var i = 0; i &lt;= segments.length; i++) { route = route.replace(/\\[([^,\\]]*)\\]/g, '$1'); } var attributes = terms.filter(term =&gt; term.indexOf('/') !== 0).join(','); if (attributes) { for (var j = 0; j &lt; 4 - segments.length; j++) { route += '/all'; } route += '/' + attributes; } return route.match(/filter$/) ? route + '/all' : route; } }, /** * Object in which you can add event listeners for Kambi Widget API events * Valid events listeners: * * 'WIDGET:HEIGHT': Widget height changed * * 'OUTCOME:REMOVED:{outcomeId}': Outcome with {outcomeId} removed * * 'OUTCOME:ADDED:{outcomeId}': Outcome with {outcomeId} added * * 'OUTCOME:UPDATE:{outcomeId}': Outcome with {outcomeId} updated * * 'WIDGET:ARGS': Widget args changed * * 'PAGE:INFO': Page info changed * * 'ODDS:FORMAT': Odds format changed * * 'CLIENT:CONFIG': Client config changed * * 'USER:LOGGED_IN': User logged in changed * * @example * * widgetModule.events * .subscribe('OUTCOME:ADDED:' + outcome.id, * ( data ) =&gt; { * ... * }); * * @type {Object} * @property {Function} subscribe Parameters: (eventName, eventHandlerFn). Subscribes to the eventName, when that event happens eventHandlerFn is called * @property {Function} unsubscribe Parameters: (eventName, eventHandlerFn). Unsubscribes all handlers to the event or if an eventHandlerFn is passed, only unsubscribes that handler */ events: (function() { /** * Map of events with handlers * @type {object&lt;string, function[]&gt;} */ const handlers = {}; /** * Subscribes a handler to given event. * @param {string} event Event name * @param {function} handler Handler function */ const subscribe = function(event, handler) { if (handlers.hasOwnProperty(event)) { handlers[event].push(handler); } else { handlers[event] = [handler]; } }; /** * Unsubscribes handler/all handlers from given event. * @param {string} event Event name * @param {function?} handler Optional handler function pointer */ const unsubscribe = function(event, handler) { if (handlers.hasOwnProperty(event)) { // remove all handlers for given event if (!handler) { handlers[event] = []; return; } // remove particular handler const handlerIdx = handlers[event].indexOf(handler); if (handlerIdx &gt; -1) { handlers[event].splice(handlerIdx, 1); } } }; /** * Emits an event with given arguments. * @param {string} event Event name * @param {...*} args Arguments for handlers * @private */ const publish = function(event, ...args) { if (!handlers.hasOwnProperty(event)) { return; } handlers[event].forEach(handler =&gt; handler.apply(undefined, args)); }; // api return { subscribe, unsubscribe, publish }; })(), /** * Stores all the betslip outcome ids we are watching * to trigger events * @type {array} * @private */ betslipIds: [], /** * Handles widget api response. * Emits events for each response * @param {Object} response * @private */ handleResponse (response) { switch (response.type) { case this.api.WIDGET_HEIGHT: // We've received a height response this.events.publish('WIDGET:HEIGHT', response.data); break; case this.api.BETSLIP_OUTCOMES: // We've received a response with the outcomes currently in the betslip var i = 0, len = response.data.outcomes.length; var updateIds = []; // Gather all the ids in the betslip in one array for (; i &lt; len; ++i) { updateIds.push(response.data.outcomes[i].id); } // Diff against what the coreLibrary already has stored so we know what was added and what was removed var removedIds = utilModule.diffArray(this.betslipIds, updateIds); var addedIds = utilModule.diffArray(updateIds, this.betslipIds); // Save the updated ids this.betslipIds = updateIds; // Emit events for each removed id i = 0; len = removedIds.length; for (; i &lt; len; ++i) { this.events.publish('OUTCOME:REMOVED:' + removedIds[i]); } // Emit events for each added id i = 0; len = addedIds.length; for (; i &lt; len; ++i) { this.events.publish('OUTCOME:ADDED:' + addedIds[i]); } // Emit a generic update in case we want to use that this.events.publish('OUTCOMES:UPDATE', response.data); break; case this.api.WIDGET_ARGS: // We've received a response with the arguments set in the coreLibrary.args = response.data; this.events.publish('WIDGET:ARGS', response.data); break; case this.api.PAGE_INFO: // Received page info response coreLibrary.setPageInfo(response.data); this.events.publish('PAGE:INFO', response.data); break; case this.api.CLIENT_ODDS_FORMAT: // Received odds format response coreLibrary.setOddsFormat(response.data); this.events.publish('ODDS:FORMAT', response.data); break; case this.api.CLIENT_CONFIG: coreLibrary.setConfig(response.data); this.events.publish('CLIENT:CONFIG', response.data); break; case this.api.USER_LOGGED_IN: console.debug('User logged in', response.data); this.events.publish('USER:LOGGED_IN', response.data); break; case 'Setup': this.events.publish('Setup response', response.data); break; default: // Unhandled response console.info('Unhandled response type: ' + response.type); console.info(response); break; } }, /** * Creates url from given path and optionalRoot * @param {String} path * @param {String} optionalRoot * @returns {String} */ createUrl (path, optionalRoot) { return this.api.createUrl(path, optionalRoot); }, /** * Creates a filter url from given array * @example * destination = ['/football/europa_league/', '/football/world_cup_qualifying_-_europe/']; * @param {Array} destination * @returns {string} */ createFilterUrl (destination) { return this.api.createFilterUrl(destination, coreLibrary.config.routeRoot); }, /** * Returns the page type page type * @returns {String} */ getPageType () { if (!coreLibrary.pageInfo.pageType) { return ''; } var pageType = coreLibrary.pageInfo.pageType; switch (pageType) { case 'event': return ''; case 'event-live': return 'live/'; default: console.info('Unknown page type: ' + pageType); break; } }, /** * Makes widget api request for setupdata * @param {fn} callback Callback */ requestSetup (callback) { this.api.requestSetup(callback); }, /** * Requests widget height from widget api */ requestWidgetHeight () { this.api.request(this.api.WIDGET_HEIGHT); }, /** * Set widget iframe height * @param {Number} height the height in pixels */ setWidgetHeight (height) { this.api.set(this.api.WIDGET_HEIGHT, height); }, /** * tries to adapt the widget iframe height to match the content * * Only works if the html and body tags don't have height: 100% styling rule */ adaptWidgetHeight () { // tries to adapt the widget iframe height to match the content var body = document.body, html = document.documentElement; var height = Math.max(body.offsetHeight, html.scrollHeight, html.offsetHeight); this.api.set(this.api.WIDGET_HEIGHT, height); }, /** * Enables/disables animations of changing the height of the iframe * @param {boolean} enableTransition new state to be */ enableWidgetTransition (enableTransition) { if (enableTransition) { this.api.set(this.api.WIDGET_ENABLE_TRANSITION); } else { this.api.set(this.api.WIDGET_DISABLE_TRANSITION); } }, /** * Call api to remove widget from the sportsbook */ removeWidget () { this.api.remove(); }, /** * Method to navigate to a live event page * @param {number} eventId */ navigateToLiveEvent (eventId) { this.navigateClient('event/live/' + eventId); }, /** * Method to navigate to a pre-live event page * @param {number} eventId */ navigateToEvent (eventId) { this.navigateClient('event/' + eventId); }, /** * Method to navigate to a filter page * @param {String} filterParams */ navigateToFilter (filterParams) { if (typeof filterParams === 'string' &amp;&amp; filterParams.indexOf('filter/') === -1) { filterParams = 'filter/' + filterParams; } this.navigateClient(filterParams); }, /** * Navigates to the live events page */ navigateToLiveEvents () { this.navigateClient(['in-play']); }, /** * Adds an outcomes to the betslip * @param {Array&lt;Number&gt;|Number} outcomes ids of the outcomes to add * @param {Array&lt;Number&gt;|Number} stakes the value of the stakes to add (referencing the ids in the outcomes parameter) * @param {String} updateMode defaults to 'append', but also accepts 'replace' * @param {String} source */ addOutcomeToBetslip (outcomes, stakes, updateMode, source) { var arrOutcomes = []; // Check if the outcomes parameter is an array and add it, otherwise add the the single value as an array if (Array.isArray(outcomes)) { arrOutcomes = outcomes; } else { arrOutcomes.push(outcomes); } // Setup the data object to be sent to the widget API var data = { outcomes: arrOutcomes }; // Check if we got any stakes passed to use, add them to the data object if so if (stakes != null) { if (Array.isArray(stakes)) { data.stakes = stakes; } else { data.stakes = [stakes]; } } // Set the coupon type, defaults to TYPE_SINGLE data.couponType = arrOutcomes.length === 1 ? this.api.BETSLIP_OUTCOMES_ARGS.TYPE_SINGLE : this.api.BETSLIP_OUTCOMES_ARGS.TYPE_COMBINATION; // Set the update mode, defaults to UPDATE_APPEND data.updateMode = updateMode !== 'replace' ? this.api.BETSLIP_OUTCOMES_ARGS.UPDATE_APPEND : this.api.BETSLIP_OUTCOMES_ARGS.UPDATE_REPLACE; if (source != null) { data.source = source; } // Add tracking name if it's set if (coreLibrary.widgetTrackingName != null) { data.name = coreLibrary.widgetTrackingName; } // Send the data to the widget this.api this.api.set(this.api.BETSLIP_OUTCOMES, data); }, /** * Removes outcomes from betslip * @param {Array&lt;Number&gt;|Number} outcomes ids of the outcomes to remove form the betslip */ removeOutcomeFromBetslip (outcomes) { var arrOutcomes = []; if (Array.isArray(outcomes)) { arrOutcomes = outcomes; } else { arrOutcomes.push(outcomes); } var data = { outcomes: arrOutcomes }; // Add tracking name if it's set if (coreLibrary.widgetTrackingName != null) { data.name = coreLibrary.widgetTrackingName; } this.api.set(this.api.BETSLIP_OUTCOMES_REMOVE, data); }, /** * Requests betslip outcomes */ requestBetslipOutcomes () { this.api.request(this.api.BETSLIP_OUTCOMES); }, /** * Requests page info */ requestPageInfo () { this.api.request(this.api.PAGE_INFO); }, /** * Requests widget args */ requestWidgetArgs () { this.api.request(this.api.WIDGET_ARGS); }, /** * Requests client config */ requestClientConfig () { this.api.request(this.api.CLIENT_CONFIG); }, /** * Requests odds format */ requestOddsFormat () { this.api.request(this.api.CLIENT_ODDS_FORMAT); }, /** * Requests american odds * @param {Number} odds * @returns {Promise} */ requestOddsAsAmerican (odds) { return new Promise((resolve) =&gt; { this.api.requestOddsAsAmerican(odds, (americanOdds) =&gt; { resolve(americanOdds); }); }); }, /** * Requests fractional odds * @param {Number} odds * @returns {Promise} */ requestOddsAsFractional (odds) { return new Promise((resolve) =&gt; { this.api.requestOddsAsFractional(odds, (fractionalOdds) =&gt; { resolve(fractionalOdds); }); }); }, /** * Navigates to a page in the sportsbook * @param {String|Array} destination fragment part of the URL to navigate to (the part after the # in the URL) */ navigateClient (destination) { var finalTarget = ''; if (typeof destination === 'string') { finalTarget = '#' + coreLibrary.config.routeRoot + destination; } else if (Array.isArray(destination)) { finalTarget = this.api.createFilterUrl(destination, coreLibrary.config.routeRoot); } if (coreLibrary.widgetTrackingName != null) { this.api.navigateClient(finalTarget, coreLibrary.widgetTrackingName); } else { this.api.navigateClient(finalTarget); } } }; × Search results Close Documentation generated by JSDoc 3.4.2 on Thu Oct 20th 2016 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials Building and Deploying Widgets Modules × Search results Close Documentation generated by JSDoc 3.4.2 on Thu Oct 20th 2016 using the DocStrap template. "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials Building and Deploying Widgets Tutorials × Search results Close Documentation generated by JSDoc 3.4.2 on Thu Oct 20th 2016 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials Building and Deploying Widgets widget-core-libraryCollection of methods and settings common to all widgets, contains the initial communication with KambiWidgetApi and support for i18n. × Search results Close Documentation generated by JSDoc 3.4.2 on Thu Oct 20th 2016 using the DocStrap template. "},"module-coreLibrary.html":{"id":"module-coreLibrary.html","title":"Module: coreLibrary","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials Building and Deploying Widgets Module: coreLibrary Main module that holds the other modules as well as widgetrelated configurations Source: coreLibrary.js, line 7 Members &lt;static&gt; browser :String Name of the browser that is running the widget Type: String Source: coreLibrary.js, line 108 &lt;static&gt; browserVersion :String Browser version Type: String Source: coreLibrary.js, line 114 &lt;static&gt; cssLoadedPromise :Promise Promise that is resolved when all the CSS has finished loading Type: Promise Source: coreLibrary.js, line 358 &lt;inner&gt; apiVersions :Object Versions of the API provided by the sportsbook Type: Object Properties: Name Type Description client String libs String wapi String Source: coreLibrary.js, line 320 &lt;inner&gt; args args object for the widget, merges the default args provided by coreLibrary.init() with the ones that come from the sportsbook. There are some pre-defined arguments that all widgets accept, but most of them are widget-defined. Properties: Name Type Description customCssUrl String URL to a CSS file to add to the page, expressions like &quot;{customer}&quot; are replaced with their values in coreLibrary.config. This is useful to load different stylesheets based on operator name. Example: Say coreLibrary.config.customer is 'kambi', then if this argument was set: { customCssUrl: &quot;https://someurl.com/customcss/{customer}/style.css&quot; } It would load this CSS file and add it to the page: https://someurl.com/customcss/kambi/style.css customCssUrlFallback String fallback if the fetching of customCssUrl fails conditionalArgs Array.&lt;Object&gt; Optional, specify arguments to be applied based on some condition based in the values inside coreLibrary.config or coreLibrary.pageInfo example: conditionalArgs: [ // if coreLibrary.config.currency is 'EUR' apply { euro: true, dollars: false } to the arguments { config: { currency: 'EUR' }, args: { euro: true, dollars: false } }, // if market is 'IT' AND offering is 'IT' apply { italian: true } to the arguments { config: { market: 'IT', offering: 'IT' }, args: { italian: true } }, ] Source: coreLibrary.js, line 205 &lt;inner&gt; config :Object Config object. This data comes from the sportsbook and should not be manually changed. When in running the widget stand alone this values are retrieved from ./src/mockSetupData.json Type: Object Properties: Name Type Description apiBaseUrl String url of the offering api to use auth Boolean channelId Number currency String what currency to use customer String the customer to use with the offering API device String what kind of device does the user have. Possible values: 'desktop', 'mobile' locale String locale of the user, example: 'en_GB', 'sv_SE' market String market to use with the offering API. oddsFormat String the odds format to show. Possible values: 'decimal', 'fractional', 'american'. To listen to changes to this value use widgetModule.events.subscribe('ODDS:FORMAT', eventHandlerFn); offering String the offering to use with the offering API routeRoot String streamingAllowedForPlayer Boolean client_id Number version String Source: coreLibrary.js, line 123 &lt;inner&gt; pageInfo :Object Information about the page that the widget is being loaded from Type: Object Properties: Name Type Description leaguePaths Array(String) array with league paths. Example:['football/england/premier_league'] pageParam String parameter for this page. For a page of type 'filter' an example would be 'football/england/premier_league' pageTrackingPath String the path in the url for this page. For example: '/filter/football/england/premier_league' pageType String type of the page, examples: 'home', 'filter' Source: coreLibrary.js, line 290 Methods &lt;static&gt; getData(url) Makes a ajax request and parses its response as JSON Parameters: Name Type Description url String Source: coreLibrary.js, line 564 Returns: resolved when the data fetching finishes. If an error happens during fetching the error can be catched in a .catch() function Type Promise &lt;static&gt; getFile(url) Makes an ajax request and returns the response body as text Parameters: Name Type Description url String Source: coreLibrary.js, line 582 Returns: resolved when the data fetching finishes. If an error happens during fetching the error can be catched in a .catch() function Type Promise &lt;static&gt; init(defaultArgs) Initializes the Kambi apiUses ./src/mockSetupData.json as coreLibrary.configs if not loaded inside the sportsbook (ie opened the widget directly). Parameters: Name Type Description defaultArgs Object arguments to be used if they are not provided by the sportsbook Source: coreLibrary.js, line 366 Returns: resolved when everything is ready. If an error happens during fetching the error can be catched in a .catch() function Type Promise &lt;static&gt; setWidgetTrackingName(name) Sets widget tracking name for analytics purposes. This tracking name is used for calls to add bets to the betslip Parameters: Name Type Description name String The name to use Source: coreLibrary.js, line 597 × Search results Close Documentation generated by JSDoc 3.4.2 on Thu Oct 20th 2016 using the DocStrap template. "},"module-offeringModule.html":{"id":"module-offeringModule.html","title":"Module: offeringModule","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials Building and Deploying Widgets Module: offeringModule Module with methods to request data from the offering APIThe offering API has information concerning events (matches, competations) and their respective betoffers as well as live data if availableAll methods in this module return Promises that are resolved when the data is ready and throws errors (that can be handled with .catch()) on failure Source: Module/offeringModule.js, line 3 Methods &lt;static&gt; doRequest(requestPath, params, version, noCache) Makes a request to provided path setting the appropriated URL parameters. Usually this method should not be called directly, unless you want to access an endpoint that is not available in the other methods The final url looks like: coreLibrary.config.apiBaseUrl + version + coreLibrary.config.offering + requestPath Example (same as calling offeringModule.getLiveEvents() but forcing to use Portugal Portuguese locale) doRequest('/event/live/open.json' { lang: 'pt_PT' }); this call would fetch this url: https://api.kambi.com/offering/api/v2/kambi/event/live/open.json?lang=pt_PT&amp;market=kambi&amp;client_id=2&amp;include=&amp;betOffers=COMBINED&amp;categoryGroup=COMBINED&amp;displayDefault=true&amp;nocache=1476973932524 Parameters: Name Type Description requestPath string the path to the request params object params to use, can override the parameters this method usually sets version number | string which version of the API to use. Some endpoints are 'v2' and some are 'v3' noCache boolean if true will add a cache-busting URL parameter. Defaults to true Source: Module/offeringModule.js, line 245 Returns: Type Promise &lt;static&gt; getEvent(eventId) Requests and event from api Parameters: Name Type Description eventId String The event id we need to fetch Source: Module/offeringModule.js, line 193 Returns: Type Promise &lt;static&gt; getEventsByFilter(filter, params) Get events by filter Parameters: Name Type Description filter String Filter string, eg: football params Object Request relevant parameters Source: Module/offeringModule.js, line 38 Returns: Type Promise &lt;static&gt; getGroup(groupId) Get group information. Parameters: Name Type Description groupId Number | String Group id Source: Module/offeringModule.js, line 27 Returns: Type Promise &lt;static&gt; getGroupEvents(groupId) Get group events Parameters: Name Type Description groupId number | string Group id Source: Module/offeringModule.js, line 17 Returns: Type Promise &lt;static&gt; getHighlight() Request the highlight resource which is what is shown under the &quot;Popular&quot; section in the Sportsbook Source: Module/offeringModule.js, line 210 Returns: Type Promise &lt;static&gt; getLiveEvent(eventId) Returns a live event Parameters: Name Type Description eventId Number | String The event id we need to fetch Source: Module/offeringModule.js, line 134 Returns: Type Promise &lt;static&gt; getLiveEventsByFilter(filter) Get live events by filter Parameters: Name Type Description filter String Filter string Source: Module/offeringModule.js, line 153 Returns: Type Promise × Search results Close Documentation generated by JSDoc 3.4.2 on Thu Oct 20th 2016 using the DocStrap template. "},"module-statisticsModule.html":{"id":"module-statisticsModule.html","title":"Module: statisticsModule","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials Building and Deploying Widgets Module: statisticsModule Module to access statistics APIThe statistics API has information concerning historical data of events (matches, competitions)All methods in this module return Promises that are resolved when the data is ready and throws errors (that can be handled with .catch()) on failure Source: Module/statisticsModule.js, line 3 Members &lt;static&gt; config :Object Configuration Type: Object Properties: Name Type Description baseApiUrl String the baseURL for statistics API requests Source: Module/statisticsModule.js, line 17 Methods &lt;static&gt; getHeadToHeadStatistics(eventId) Requests H2H statistics data from api. Parameters: Name Type Description eventId String | Number id of a match Source: Module/statisticsModule.js, line 45 Returns: Type Promise &lt;static&gt; getLeagueTableStatistics(filter) Requests league table statistics data from api. Parameters: Name Type Description filter String a filter string to a competition. Example 'football/england/premier_league' Source: Module/statisticsModule.js, line 26 Returns: Type Promise &lt;static&gt; getTeamPerformanceStatistics(eventId) Requests TPI statistics data from api. Parameters: Name Type Description eventId String | Number id of a match Source: Module/statisticsModule.js, line 54 Returns: Type Promise × Search results Close Documentation generated by JSDoc 3.4.2 on Thu Oct 20th 2016 using the DocStrap template. "},"module-translationModule.html":{"id":"module-translationModule.html","title":"Module: translationModule","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials Building and Deploying Widgets Module: translationModule Module with internationalization methodsProvides a very simple internationalization mechanismthat is not relient in any library.The loading of the right internationalization JSON file is handled automatically Source: Module/translationModule.js, line 3 Members &lt;static&gt; i18nStrings :Object fetched from the i18n folder JSON files. Only the currentlocale strings are fetched Type: Object Source: Module/translationModule.js, line 16 Methods &lt;static&gt; getTranslation(key, args) Returns translated string based of a provided key. Parameters: Name Type Argument Description key String Key to fetch translation for args String &lt;repeatable&gt; arguments to replace inside the translated string Source: Module/translationModule.js, line 60 Returns: the localized string Type String Example en_GB.json: { &quot;welcomeUserToPlace&quot;: &quot;Welcome {0} to {1}&quot; } Javascript: getTranslation('welcomeUserToPlace', 'Daniel', 'Stadium') =&gt; 'Welcome Daniel to Stadium' × Search results Close Documentation generated by JSDoc 3.4.2 on Thu Oct 20th 2016 using the DocStrap template. "},"module-utilModule.html":{"id":"module-utilModule.html","title":"Module: utilModule","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials Building and Deploying Widgets Module: utilModule Module with utility functions Source: Module/utilModule.js, line 4 Methods &lt;static&gt; getOddsDecimalValue(odds) Get decimal formatted odds. Parameters: Name Type Description odds Number Odds number Source: Module/utilModule.js, line 54 Returns: Type Number &lt;static&gt; getOutcomeLabel(outcome, event) Returns the outcome label translated. Parameters: Name Type Description outcome Object A betoffer outcome object event Object Event object Source: Module/utilModule.js, line 70 Returns: Type string × Search results Close Documentation generated by JSDoc 3.4.2 on Thu Oct 20th 2016 using the DocStrap template. "},"module-widgetModule.html":{"id":"module-widgetModule.html","title":"Module: widgetModule","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials Building and Deploying Widgets Module: widgetModule Module with methods to manipulate the widget and interact with the sportsbook Source: Module/widgetModule.js, line 1 Members &lt;static&gt; events :Object Object in which you can add event listeners for Kambi Widget API eventsValid events listeners: 'WIDGET:HEIGHT': Widget height changed 'OUTCOME:REMOVED:{outcomeId}': Outcome with {outcomeId} removed 'OUTCOME:ADDED:{outcomeId}': Outcome with {outcomeId} added 'OUTCOME:UPDATE:{outcomeId}': Outcome with {outcomeId} updated 'WIDGET:ARGS': Widget args changed 'PAGE:INFO': Page info changed 'ODDS:FORMAT': Odds format changed 'CLIENT:CONFIG': Client config changed 'USER:LOGGED_IN': User logged in changed Type: Object Properties: Name Type Description subscribe function Parameters: (eventName, eventHandlerFn). Subscribes to the eventName, when that event happens eventHandlerFn is called unsubscribe function Parameters: (eventName, eventHandlerFn). Unsubscribes all handlers to the event or if an eventHandlerFn is passed, only unsubscribes that handler Source: Module/widgetModule.js, line 121 Example widgetModule.events .subscribe('OUTCOME:ADDED:' + outcome.id, ( data ) =&gt; { ... }); Methods &lt;static&gt; adaptWidgetHeight() tries to adapt the widget iframe height to match the content Only works if the html and body tags don't have height: 100% styling rule Source: Module/widgetModule.js, line 336 &lt;static&gt; addOutcomeToBetslip(outcomes, stakes, updateMode, source) Adds an outcomes to the betslip Parameters: Name Type Description outcomes Array.&lt;Number&gt; | Number ids of the outcomes to add stakes Array.&lt;Number&gt; | Number the value of the stakes to add (referencing the ids in the outcomes parameter) updateMode String defaults to 'append', but also accepts 'replace' source String Source: Module/widgetModule.js, line 405 &lt;static&gt; createFilterUrl(destination) Creates a filter url from given array Parameters: Name Type Description destination Array Source: Module/widgetModule.js, line 284 Returns: Type string Example destination = ['/football/europa_league/', '/football/world_cup_qualifying_-_europe/']; &lt;static&gt; createUrl(path, optionalRoot) Creates url from given path and optionalRoot Parameters: Name Type Description path String optionalRoot String Source: Module/widgetModule.js, line 273 Returns: Type String &lt;static&gt; enableWidgetTransition(enableTransition) Enables/disables animations of changing the height of the iframe Parameters: Name Type Description enableTransition boolean new state to be Source: Module/widgetModule.js, line 348 &lt;static&gt; getPageType() Returns the page type page type Source: Module/widgetModule.js, line 292 Returns: Type String &lt;static&gt; navigateClient(destination) Navigates to a page in the sportsbook Parameters: Name Type Description destination String | Array fragment part of the URL to navigate to (the part after the # in the URL) Source: Module/widgetModule.js, line 532 &lt;static&gt; navigateToEvent(eventId) Method to navigate to a pre-live event page Parameters: Name Type Description eventId number Source: Module/widgetModule.js, line 375 &lt;static&gt; navigateToFilter(filterParams) Method to navigate to a filter page Parameters: Name Type Description filterParams String Source: Module/widgetModule.js, line 383 &lt;static&gt; navigateToLiveEvent(eventId) Method to navigate to a live event page Parameters: Name Type Description eventId number Source: Module/widgetModule.js, line 367 &lt;static&gt; navigateToLiveEvents() Navigates to the live events page Source: Module/widgetModule.js, line 394 &lt;static&gt; removeOutcomeFromBetslip(outcomes) Removes outcomes from betslip Parameters: Name Type Description outcomes Array.&lt;Number&gt; | Number ids of the outcomes to remove form the betslip Source: Module/widgetModule.js, line 450 &lt;static&gt; removeWidget() Call api to remove widget from the sportsbook Source: Module/widgetModule.js, line 359 &lt;static&gt; requestBetslipOutcomes() Requests betslip outcomes Source: Module/widgetModule.js, line 470 &lt;static&gt; requestClientConfig() Requests client config Source: Module/widgetModule.js, line 491 &lt;static&gt; requestOddsAsAmerican(odds) Requests american odds Parameters: Name Type Description odds Number Source: Module/widgetModule.js, line 507 Returns: Type Promise &lt;static&gt; requestOddsAsFractional(odds) Requests fractional odds Parameters: Name Type Description odds Number Source: Module/widgetModule.js, line 520 Returns: Type Promise &lt;static&gt; requestOddsFormat() Requests odds format Source: Module/widgetModule.js, line 498 &lt;static&gt; requestPageInfo() Requests page info Source: Module/widgetModule.js, line 477 &lt;static&gt; requestSetup(callback) Makes widget api request for setupdata Parameters: Name Type Description callback fn Callback Source: Module/widgetModule.js, line 312 &lt;static&gt; requestWidgetArgs() Requests widget args Source: Module/widgetModule.js, line 484 &lt;static&gt; requestWidgetHeight() Requests widget height from widget api Source: Module/widgetModule.js, line 319 &lt;static&gt; setWidgetHeight(height) Set widget iframe height Parameters: Name Type Description height Number the height in pixels Source: Module/widgetModule.js, line 327 × Search results Close Documentation generated by JSDoc 3.4.2 on Thu Oct 20th 2016 using the DocStrap template. "},"tutorial-Building and Deploying Widgets.html":{"id":"tutorial-Building and Deploying Widgets.html","title":"Tutorial: Building and Deploying Widgets","body":" Kambi Widgets Modules coreLibraryofferingModulestatisticsModuletranslationModuleutilModulewidgetModule Tutorials Building and Deploying Widgets Building and Deploying Widgets IntroductionTo build and deploy a widget it is necessary to Pre-requisites Install Nodejs latest version Install Gulp: npm install -g gulp Building Clone the widget repository you want to build. For example to clone the twitter widget: git clone git@github.com:kambi-sportsbook-widgets/twitter-widget.git Move to the cloned repository folder (cd twitter-widget) Run: npm install Note that the first time you do this (for each repository) it can take a few minutes Run: gulp default-bundle The built version for the widget will be inside the dist folder Subsequent builds only need to run gulp default-bundle again. If a new version of the widget is downloaded from the repostiory then it is necessary to run npm install again Deploying Copy the contents of the dist folder to where you host your widgets Point the Kambi Sportsbook to the index.html file inside that folder See each widget README about arguments that need to be passed through the Sportsbook to the widget × Search results Close Documentation generated by JSDoc 3.4.2 on Thu Oct 20th 2016 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
